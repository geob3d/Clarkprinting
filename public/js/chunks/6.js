(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[6],{

/***/ "./node_modules/vue-free-transform/dist/FreeTransform.common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vue-free-transform/dist/FreeTransform.common.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"fb15\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"0d58\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(\"ce10\");\nvar enumBugKeys = __webpack_require__(\"e11e\");\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ \"11e9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pIE = __webpack_require__(\"52a7\");\nvar createDesc = __webpack_require__(\"4630\");\nvar toIObject = __webpack_require__(\"6821\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar has = __webpack_require__(\"69a8\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"c69a\");\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(\"9e1e\") ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ \"1495\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar getKeys = __webpack_require__(\"0d58\");\n\nmodule.exports = __webpack_require__(\"9e1e\") ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"230e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar document = __webpack_require__(\"7726\").document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"2540\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (_ref, onUpdate) {\n  var x = _ref.x,\n      y = _ref.y,\n      startX = _ref.startX,\n      startY = _ref.startY;\n  return function (dragEvent) {\n\n    x += dragEvent.pageX - startX;\n    y += dragEvent.pageY - startY;\n\n    onUpdate({ x: x, y: y });\n\n    startX = dragEvent.pageX;\n    startY = dragEvent.pageY;\n  };\n};\n\n/***/ }),\n\n/***/ \"255b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n!function(r,n){ true?module.exports=n():undefined}(window,function(){return function(r){var n={};function t(e){if(n[e])return n[e].exports;var o=n[e]={i:e,l:!1,exports:{}};return r[e].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=r,t.c=n,t.d=function(r,n,e){t.o(r,n)||Object.defineProperty(r,n,{enumerable:!0,get:e})},t.r=function(r){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(r,\"__esModule\",{value:!0})},t.t=function(r,n){if(1&n&&(r=t(r)),8&n)return r;if(4&n&&\"object\"==typeof r&&r&&r.__esModule)return r;var e=Object.create(null);if(t.r(e),Object.defineProperty(e,\"default\",{enumerable:!0,value:r}),2&n&&\"string\"!=typeof r)for(var o in r)t.d(e,o,function(n){return r[n]}.bind(null,o));return e},t.n=function(r){var n=r&&r.__esModule?function(){return r.default}:function(){return r};return t.d(n,\"a\",n),n},t.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},t.p=\"\",t(t.s=0)}([function(r,n,t){\"use strict\";function e(r,n){return Array.isArray(n)?[r.a*n[0]+r.c*n[1]+r.e,r.b*n[0]+r.d*n[1]+r.f]:{x:r.a*n.x+r.c*n.y+r.e,y:r.b*n.x+r.d*n.y+r.f}}function o(r,n){return n.map(function(n){return e(r,n)})}function u(r){return{a:parseFloat(r.a),b:parseFloat(r.b),c:parseFloat(r.c),d:parseFloat(r.d),e:parseFloat(r.e),f:parseFloat(r.f)}}t.r(n);var a=/^matrix\\(\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*\\)$/i;function i(r){var n=r.match(a);if(null===n||n.length<7)throw new Error(\"'\"+r+\"' is not a matrix\");return{a:parseFloat(n[1]),b:parseFloat(n[2]),c:parseFloat(n[3]),d:parseFloat(n[4]),e:parseFloat(n[5]),f:parseFloat(n[6])}}function f(){return{a:1,c:0,e:0,b:0,d:1,f:0}}function c(r){var n=r.a,t=r.b,e=r.c,o=r.d,u=r.e,a=r.f,i=n*o-t*e;return{a:o/i,b:t/-i,c:e/-i,d:n/i,e:(o*u-e*a)/-i,f:(t*u-n*a)/i}}var d=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&\"function\"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?\"symbol\":typeof r},s=function(r){return\"number\"==typeof r&&!isNaN(r)&&isFinite(r)},l=function(r){return null!=r&&\"object\"===(void 0===r?\"undefined\":d(r))};function p(r){return l(r)&&r.hasOwnProperty(\"a\")&&s(r.a)&&r.hasOwnProperty(\"b\")&&s(r.b)&&r.hasOwnProperty(\"c\")&&s(r.c)&&r.hasOwnProperty(\"d\")&&s(r.d)&&r.hasOwnProperty(\"e\")&&s(r.e)&&r.hasOwnProperty(\"f\")&&s(r.f)}function y(r){return void 0===r}function b(r){return{a:1,c:0,e:r,b:0,d:1,f:arguments.length>1&&void 0!==arguments[1]?arguments[1]:0}}function v(){for(var r=arguments.length,n=Array(r),t=0;t<r;t++)n[t]=arguments[t];var e=function(r,n){return{a:r.a*n.a+r.c*n.b,c:r.a*n.c+r.c*n.d,e:r.a*n.e+r.c*n.f+r.e,b:r.b*n.a+r.d*n.b,d:r.b*n.c+r.d*n.d,f:r.b*n.e+r.d*n.f+r.f}};switch((n=Array.isArray(n[0])?n[0]:n).length){case 0:throw new Error(\"no matrices provided\");case 1:return n[0];case 2:return e(n[0],n[1]);default:var o=function(r){return Array.isArray(r)?r:Array.from(r)}(n),u=o[0],a=o[1],i=o.slice(2),f=e(u,a);return v.apply(void 0,[f].concat(function(r){if(Array.isArray(r)){for(var n=0,t=Array(r.length);n<r.length;n++)t[n]=r[n];return t}return Array.from(r)}(i)))}}function m(){return v.apply(void 0,arguments)}var h=Math.cos,x=Math.sin,g=Math.PI;function w(r,n,t){var e=h(r),o=x(r),u={a:e,c:-o,e:0,b:o,d:e,f:0};return y(n)||y(t)?u:v([b(n,t),u,b(-n,-t)])}function P(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;return w(r*g/180,n,t)}function S(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;return y(n)&&(n=r),{a:r,c:0,e:0,b:0,d:n,f:0}}function O(r,n){return{a:1,c:r,e:0,b:n,d:1,f:0}}var A=Math.tan;function F(r,n){return{a:1,c:A(r),e:0,b:A(n),d:1,f:0}}function M(r,n){return F(r*Math.PI/180,n*Math.PI/180)}function j(r){return T(r)}function _(r){return T(r)}function T(r){return\"matrix(\"+r.a+\",\"+r.b+\",\"+r.c+\",\"+r.d+\",\"+r.e+\",\"+r.f+\")\"}t.d(n,\"applyToPoint\",function(){return e}),t.d(n,\"applyToPoints\",function(){return o}),t.d(n,\"fromObject\",function(){return u}),t.d(n,\"fromString\",function(){return i}),t.d(n,\"identity\",function(){return f}),t.d(n,\"inverse\",function(){return c}),t.d(n,\"isAffineMatrix\",function(){return p}),t.d(n,\"rotate\",function(){return w}),t.d(n,\"rotateDEG\",function(){return P}),t.d(n,\"scale\",function(){return S}),t.d(n,\"shear\",function(){return O}),t.d(n,\"skew\",function(){return F}),t.d(n,\"skewDEG\",function(){return M}),t.d(n,\"toCSS\",function(){return j}),t.d(n,\"toSVG\",function(){return _}),t.d(n,\"toString\",function(){return T}),t.d(n,\"transform\",function(){return v}),t.d(n,\"compose\",function(){return m}),t.d(n,\"translate\",function(){return b})}])});\n//# sourceMappingURL=transformation-matrix.min.js.map\n\n/***/ }),\n\n/***/ \"2aba\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar hide = __webpack_require__(\"32e9\");\nvar has = __webpack_require__(\"69a8\");\nvar SRC = __webpack_require__(\"ca5a\")('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(\"8378\").inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n/***/ }),\n\n/***/ \"2aeb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(\"cb7c\");\nvar dPs = __webpack_require__(\"1495\");\nvar enumBugKeys = __webpack_require__(\"e11e\");\nvar IE_PROTO = __webpack_require__(\"613b\")('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(\"230e\")('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(\"fab2\").appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ \"2d00\":\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ \"2d95\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"32e9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(\"86cc\");\nvar createDesc = __webpack_require__(\"4630\");\nmodule.exports = __webpack_require__(\"9e1e\") ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"4588\":\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n\n/***/ \"4630\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"52a7\":\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ \"5537\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(\"8378\");\nvar global = __webpack_require__(\"7726\");\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(\"2d00\") ? 'pure' : 'global',\n  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"5ca1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"7726\");\nvar core = __webpack_require__(\"8378\");\nvar hide = __webpack_require__(\"32e9\");\nvar redefine = __webpack_require__(\"2aba\");\nvar ctx = __webpack_require__(\"9b43\");\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n\n/***/ \"5dbc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nvar setPrototypeOf = __webpack_require__(\"8b97\").set;\nmodule.exports = function (that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {\n    setPrototypeOf(that, P);\n  } return that;\n};\n\n\n/***/ }),\n\n/***/ \"613b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(\"5537\")('keys');\nvar uid = __webpack_require__(\"ca5a\");\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ \"626a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(\"2d95\");\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n\n/***/ \"6821\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(\"626a\");\nvar defined = __webpack_require__(\"be13\");\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n\n/***/ \"69a8\":\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ \"6a99\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(\"d3f4\");\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"7726\":\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"77f1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"4588\");\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n\n/***/ \"79e5\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"8378\":\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n\n/***/ \"8675\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _pointFinder = __webpack_require__(\"959e\");\n\n/**\n * Perform Scaling based on a positioned handle\n *\n * @param {string} scaleType scale point position name\n * @param {Object} payload an object holding element information\n * @param {number} payload.startX mouse down position on X axis\n * @param {number} payload.startY mouse down position on Y axis\n * @param {number} payload.x position of x\n * @param {number} payload.y position of y\n * @param {number} payload.scaleX amount of scale for x (width)\n * @param {number} payload.scaleY amount of scale for y (height)\n * @param {number} payload.width original width\n * @param {number} payload.height original height\n * @param {number} payload.angle the angle of rotation\n * @param {number} payload.scaleLimit minimum scale limit\n * @param {boolean} payload.scaleFromCenter is scale from center\n * @param {boolean} payload.aspectRatio is scale on aspect ration\n * @param {Function} onUpdate a callback on mouse up\n *\n * @returns {Function} a function for mouse move\n */\nexports.default = function (scaleType, _ref, onUpdate) {\n  var startX = _ref.startX,\n      startY = _ref.startY,\n      x = _ref.x,\n      y = _ref.y,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      width = _ref.width,\n      height = _ref.height,\n      angle = _ref.angle,\n      scaleLimit = _ref.scaleLimit,\n      _ref$scaleFromCenter = _ref.scaleFromCenter,\n      scaleFromCenter = _ref$scaleFromCenter === undefined ? false : _ref$scaleFromCenter,\n      _ref$enableScaleFromC = _ref.enableScaleFromCenter,\n      enableScaleFromCenter = _ref$enableScaleFromC === undefined ? true : _ref$enableScaleFromC,\n      _ref$aspectRatio = _ref.aspectRatio,\n      aspectRatio = _ref$aspectRatio === undefined ? false : _ref$aspectRatio,\n      _ref$enableAspectRati = _ref.enableAspectRatio,\n      enableAspectRatio = _ref$enableAspectRati === undefined ? true : _ref$enableAspectRati;\n\n\n  var ratio = width * scaleX / (height * scaleY);\n\n  var point = (0, _pointFinder.getPoint)(scaleType, { x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height, angle: angle, scaleFromCenter: scaleFromCenter });\n\n  var oppositePoint = (0, _pointFinder.getOppositePoint)(scaleType, {\n    x: x,\n    y: y,\n    scaleX: scaleX,\n    scaleY: scaleY,\n    width: width,\n    height: height,\n    angle: angle\n  });\n\n  var currentProps = {\n    x: x,\n    y: y,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n\n  return function (event) {\n\n    if (enableScaleFromCenter && (event.altKey && !scaleFromCenter || !event.altKey && scaleFromCenter)) {\n\n      startX = event.pageX;\n      startY = event.pageY;\n\n      scaleFromCenter = event.altKey && !scaleFromCenter;\n\n      point = (0, _pointFinder.getPoint)(scaleType, _extends({}, currentProps, {\n        width: width,\n        height: height,\n        angle: angle,\n        scaleFromCenter: scaleFromCenter\n      }));\n\n      oppositePoint = (0, _pointFinder.getOppositePoint)(scaleType, _extends({}, currentProps, {\n        width: width,\n        height: height,\n        angle: angle\n      }));\n    }\n\n    if (!event.shiftKey && aspectRatio) {\n      aspectRatio = false;\n    } else if (event.shiftKey && !aspectRatio) {\n      aspectRatio = true;\n    }\n\n    if (!enableAspectRatio) {\n      aspectRatio = false;\n    }\n    var moveDiff = {\n      x: event.pageX - startX,\n      y: event.pageY - startY\n    };\n\n    var movePoint = (0, _pointFinder.getMovePoint)(scaleType, oppositePoint, point, moveDiff);\n\n    if (enableScaleFromCenter && scaleFromCenter) {\n      movePoint.x *= 2;\n      movePoint.y *= 2;\n    }\n\n    var _getSineCosine = (0, _pointFinder.getSineCosine)(scaleType, angle),\n        sin = _getSineCosine.sin,\n        cos = _getSineCosine.cos;\n\n    var rotationPoint = {\n      x: movePoint.x * cos + movePoint.y * sin,\n      y: movePoint.y * cos - movePoint.x * sin\n    };\n\n    currentProps.scaleX = rotationPoint.x / width > scaleLimit ? rotationPoint.x / width : scaleLimit;\n    currentProps.scaleY = rotationPoint.y / height > scaleLimit ? rotationPoint.y / height : scaleLimit;\n\n    switch (scaleType) {\n      case 'ml':\n      case 'mr':\n        currentProps.scaleY = scaleY;\n        if (aspectRatio) {\n          currentProps.scaleY = width * currentProps.scaleX * (1 / ratio) / height;\n        }\n        break;\n      case 'tm':\n      case 'bm':\n        currentProps.scaleX = scaleX;\n        if (aspectRatio) {\n          currentProps.scaleX = height * currentProps.scaleY * ratio / width;\n        }\n        break;\n      default:\n        if (aspectRatio) {\n          currentProps.scaleY = width * currentProps.scaleX * (1 / ratio) / height;\n        }\n    }\n\n    if (enableScaleFromCenter && scaleFromCenter) {\n      var center = (0, _pointFinder.getCenter)({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        scaleX: currentProps.scaleX,\n        scaleY: currentProps.scaleY\n      });\n      currentProps.x = x + (point.x - center.x);\n      currentProps.y = y + (point.y - center.y);\n    } else {\n      var freshOppositePoint = (0, _pointFinder.getOppositePoint)(scaleType, {\n        width: width,\n        height: height,\n        angle: angle,\n        x: x,\n        y: y,\n        scaleX: currentProps.scaleX,\n        scaleY: currentProps.scaleY\n      });\n\n      currentProps.x = x + (oppositePoint.x - freshOppositePoint.x);\n      currentProps.y = y + (oppositePoint.y - freshOppositePoint.y);\n    }\n\n    onUpdate(currentProps);\n  };\n};\n\n/***/ }),\n\n/***/ \"86cc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"cb7c\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"c69a\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(\"9e1e\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"89e1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _transformationMatrix = __webpack_require__(\"255b\");\n\n//https://stackoverflow.com/questions/15762768/javascript-math-round-to-two-decimal-places\nvar roundTo = function roundTo(n) {\n  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n\n  var multiplicator = Math.pow(10, digits);\n  n = parseFloat((n * multiplicator).toFixed(11));\n  var test = Math.round(n) / multiplicator;\n  return +test.toFixed(2);\n};\n\nexports.default = function (_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      angle = _ref.angle,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      width = _ref.width,\n      height = _ref.height,\n      _ref$disableScale = _ref.disableScale,\n      disableScale = _ref$disableScale === undefined ? false : _ref$disableScale;\n\n\n  var changedWidth = width * (1 - scaleX);\n  var newWidth = width - changedWidth;\n  var changedHeight = height * (1 - scaleY);\n  var newHeight = height - changedHeight;\n\n  var transformMatrix = void 0;\n\n  if (disableScale === false) {\n    transformMatrix = (0, _transformationMatrix.transform)((0, _transformationMatrix.translate)(roundTo(x + changedWidth / 2), roundTo(y + changedHeight / 2)), (0, _transformationMatrix.rotate)(angle * (Math.PI / 180)), (0, _transformationMatrix.scale)(scaleX, scaleY));\n  } else {\n    transformMatrix = (0, _transformationMatrix.transform)((0, _transformationMatrix.translate)(roundTo(x + changedWidth), roundTo(y + changedHeight)), (0, _transformationMatrix.rotate)(angle * (Math.PI / 180)));\n    width = newWidth;\n    height = newHeight;\n  }\n\n  return {\n    element: {\n      width: width,\n      height: height,\n      transform: (0, _transformationMatrix.toCSS)(transformMatrix),\n      position: \"absolute\"\n    },\n    controls: {\n      width: newWidth,\n      height: newHeight,\n      transform: (0, _transformationMatrix.toCSS)((0, _transformationMatrix.transform)((0, _transformationMatrix.translate)(roundTo(x + changedWidth), roundTo(y + changedHeight)), (0, _transformationMatrix.rotate)(angle * (Math.PI / 180)))),\n      position: \"absolute\"\n    }\n  };\n};\n\n/***/ }),\n\n/***/ \"8b97\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(\"d3f4\");\nvar anObject = __webpack_require__(\"cb7c\");\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(\"9b43\")(Function.call, __webpack_require__(\"11e9\").f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/***/ }),\n\n/***/ \"9093\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(\"ce10\");\nvar hiddenKeys = __webpack_require__(\"e11e\").concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ \"927f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _pointFinder = __webpack_require__(\"959e\");\n\nexports.default = function (_ref, onUpdate) {\n  var x = _ref.x,\n      y = _ref.y,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      width = _ref.width,\n      height = _ref.height,\n      angle = _ref.angle,\n      startX = _ref.startX,\n      startY = _ref.startY,\n      offsetX = _ref.offsetX,\n      offsetY = _ref.offsetY;\n\n\n  var center = (0, _pointFinder.getCenter)({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height });\n\n  var pressAngle = Math.atan2(startY - offsetY - center.y, startX - offsetX - center.x) * 180 / Math.PI;\n\n  return function (event) {\n\n    var degree = Math.atan2(event.pageY - offsetY - center.y, event.pageX - offsetX - center.x) * 180 / Math.PI;\n\n    var ang = angle + degree - pressAngle;\n\n    if (event.shiftKey) {\n      ang = (ang / 15 >> 0) * 15;\n    }\n\n    onUpdate({\n      angle: ang\n    });\n  };\n};\n\n/***/ }),\n\n/***/ \"959e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n/**\n * Find the actual point position of a transformed point\n *\n * @param {Object} payload an object holding required information to find actual point\n * @param {number} payload.x position of x\n * @param {number} payload.y position of y\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center  {{x,y}} the center of element\n * @param {number} payload.rad the a computed radians of a provided angle\n *\n * @returns {{x: number, y: number}} an object holding the position\n */\nvar findPoint = function findPoint(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      angle = _ref.angle,\n      center = _ref.center,\n      _ref$rad = _ref.rad,\n      rad = _ref$rad === undefined ? angle * (Math.PI / 180) : _ref$rad;\n  return {\n    x: (x - center.x) * Math.cos(rad) - (y - center.y) * Math.sin(rad) + center.x,\n    y: (x - center.x) * Math.sin(rad) + (y - center.y) * Math.cos(rad) + center.y\n  };\n};\n\n/**\n * Get the Center point of a box\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n *\n * @returns {{x: *, y: *}} the center of point of element\n */\nvar getCenter = exports.getCenter = function getCenter(_ref2) {\n  var x = _ref2.x,\n      y = _ref2.y,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      width = _ref2.width,\n      height = _ref2.height;\n\n  var changedWidth = width * scaleX;\n  var changedHeight = height * scaleY;\n\n  var changedWidthDiff = changedWidth - width;\n  var changedHeightDiff = changedHeight - height;\n\n  return {\n    x: x - changedWidthDiff + changedWidth / 2,\n    y: y - changedHeightDiff + changedHeight / 2\n  };\n};\n\n/**\n * get the TopLeft point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getTL = exports.getTL = function getTL(_ref3) {\n  var x = _ref3.x,\n      y = _ref3.y,\n      scaleX = _ref3.scaleX,\n      scaleY = _ref3.scaleY,\n      width = _ref3.width,\n      height = _ref3.height,\n      angle = _ref3.angle,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref3$center;\n  return findPoint({\n    x: x,\n    y: y,\n    angle: angle,\n    center: center\n  });\n};\n\n/**\n * get the LeftBottom point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getBL = exports.getBL = function getBL(_ref4) {\n  var x = _ref4.x,\n      y = _ref4.y,\n      scaleX = _ref4.scaleX,\n      scaleY = _ref4.scaleY,\n      width = _ref4.width,\n      height = _ref4.height,\n      angle = _ref4.angle,\n      _ref4$center = _ref4.center,\n      center = _ref4$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref4$center;\n\n\n  return findPoint({\n    angle: angle,\n    center: center,\n    x: x,\n    y: y + height * scaleY\n  });\n};\n\n/**\n * Get TopRight point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getTR = exports.getTR = function getTR(_ref5) {\n  var x = _ref5.x,\n      y = _ref5.y,\n      scaleX = _ref5.scaleX,\n      scaleY = _ref5.scaleY,\n      width = _ref5.width,\n      height = _ref5.height,\n      angle = _ref5.angle,\n      _ref5$center = _ref5.center,\n      center = _ref5$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref5$center;\n  return findPoint({\n    angle: angle,\n    center: center,\n    x: x + width * scaleX,\n    y: y\n  });\n};\n\n/**\n * Get BottomRight point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getBR = exports.getBR = function getBR(_ref6) {\n  var x = _ref6.x,\n      y = _ref6.y,\n      scaleX = _ref6.scaleX,\n      scaleY = _ref6.scaleY,\n      width = _ref6.width,\n      height = _ref6.height,\n      angle = _ref6.angle,\n      _ref6$center = _ref6.center,\n      center = _ref6$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref6$center;\n\n  return findPoint({\n    angle: angle,\n    center: center,\n    x: x + width * scaleX,\n    y: y + height * scaleY\n  });\n};\n\n/**\n * get MiddleRight point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getMR = exports.getMR = function getMR(_ref7) {\n  var x = _ref7.x,\n      y = _ref7.y,\n      scaleX = _ref7.scaleX,\n      scaleY = _ref7.scaleY,\n      width = _ref7.width,\n      height = _ref7.height,\n      angle = _ref7.angle,\n      _ref7$center = _ref7.center,\n      center = _ref7$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref7$center;\n  return findPoint({\n    x: x + width * scaleX,\n    y: y + height * scaleY / 2,\n    center: center,\n    angle: angle\n  });\n};\n\n/**\n * get MiddleBottom point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getBM = exports.getBM = function getBM(_ref8) {\n  var x = _ref8.x,\n      y = _ref8.y,\n      scaleX = _ref8.scaleX,\n      scaleY = _ref8.scaleY,\n      width = _ref8.width,\n      height = _ref8.height,\n      angle = _ref8.angle,\n      _ref8$center = _ref8.center,\n      center = _ref8$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref8$center;\n  return findPoint({\n    x: x + width * scaleX / 2,\n    y: y + height * scaleY,\n    center: center,\n    angle: angle\n  });\n};\n\n/**\n * get MiddleTop point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getTM = exports.getTM = function getTM(_ref9) {\n  var x = _ref9.x,\n      y = _ref9.y,\n      scaleX = _ref9.scaleX,\n      scaleY = _ref9.scaleY,\n      width = _ref9.width,\n      height = _ref9.height,\n      angle = _ref9.angle,\n      _ref9$center = _ref9.center,\n      center = _ref9$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref9$center;\n  return findPoint({\n    x: x + width * scaleX / 2,\n    y: y,\n    center: center,\n    angle: angle\n  });\n};\n\n/**\n * get MiddleLeft point position\n *\n * @param {Object} payload element information\n * @param {number} payload.x the position of x\n * @param {number} payload.y the position of y\n * @param {number} payload.scaleX the scaleX of element\n * @param {number} payload.scaleY the scaleY of element\n * @param {number} payload.width the original width of element\n * @param {number} payload.height the original height of element\n * @param {number} payload.angle the  rotation angle\n * @param {Object} payload.center {{x:number, y:number}}\n *\n * @returns {{x: number, y: number}} the position\n */\nvar getML = exports.getML = function getML(_ref10) {\n  var x = _ref10.x,\n      y = _ref10.y,\n      scaleX = _ref10.scaleX,\n      scaleY = _ref10.scaleY,\n      width = _ref10.width,\n      height = _ref10.height,\n      angle = _ref10.angle,\n      _ref10$center = _ref10.center,\n      center = _ref10$center === undefined ? getCenter({ x: x, y: y, scaleX: scaleX, scaleY: scaleY, width: width, height: height }) : _ref10$center;\n  return findPoint({\n    x: x,\n    y: y + height * scaleY / 2,\n    center: center,\n    angle: angle\n  });\n};\n\n/**\n * given a point, get it's opposite point\n *\n * @param {string} scaleType scale point position name\n * @param {Object} props element information\n * @param {number} props.x the position of x\n * @param {number} props.y the position of y\n * @param {number} props.scaleX the scaleX of element\n * @param {number} props.scaleY the scaleY of element\n * @param {number} props.width the original width of element\n * @param {number} props.height the original height of element\n * @param {number} props.angle the  rotation angle\n * @param {Object} props.center {{x:number, y:number}}\n *\n * @returns {{x:number, y:number}} point position\n */\nvar getOppositePoint = exports.getOppositePoint = function getOppositePoint(scaleType, props) {\n\n  var caller = void 0;\n\n  var center = getCenter({\n    x: props.x,\n    y: props.y,\n    width: props.width,\n    height: props.height,\n    scaleX: props.scaleX,\n    scaleY: props.scaleY\n  });\n\n  props = _extends({\n    center: center\n  }, props, {\n    x: getOriginalPositionFromScale(props.x, props.width, props.scaleX),\n    y: getOriginalPositionFromScale(props.y, props.height, props.scaleY)\n  });\n\n  switch (scaleType) {\n    case 'tl':\n      caller = getBR;\n      break;\n\n    case 'ml':\n      caller = getMR;\n      break;\n\n    case 'tr':\n      caller = getBL;\n      break;\n\n    case 'tm':\n      caller = getBM;\n      break;\n\n    case 'bl':\n      caller = getTR;\n      break;\n\n    case 'bm':\n      caller = getTM;\n      break;\n\n    case 'br':\n      caller = getTL;\n      break;\n\n    case 'mr':\n      caller = getML;\n      break;\n  }\n  return caller(props);\n};\n\n/**\n * given a point position by it's string name\n *\n * @param {string} scaleType scale point position name\n * @param {Object} props element information\n * @param {number} props.x the position of x\n * @param {number} props.y the position of y\n * @param {number} props.scaleX the scaleX of element\n * @param {number} props.scaleY the scaleY of element\n * @param {number} props.width the original width of element\n * @param {number} props.height the original height of element\n * @param {number} props.angle the  rotation angle\n * @param {boolean} props.scaleFromCenter scaling performed from center\n * @param {Object} props.center {{x:number, y:number}}\n *\n * @returns {{x:number, y:number}} point position\n */\nvar getPoint = exports.getPoint = function getPoint(scaleType, props) {\n\n  var center = getCenter({\n    x: props.x,\n    y: props.y,\n    width: props.width,\n    height: props.height,\n    scaleX: props.scaleX,\n    scaleY: props.scaleY\n  });\n\n  if (props.scaleFromCenter) {\n    return center;\n  }\n\n  props = _extends({\n    center: center\n  }, props, {\n    x: getOriginalPositionFromScale(props.x, props.width, props.scaleX),\n    y: getOriginalPositionFromScale(props.y, props.height, props.scaleY)\n  });\n\n  var caller = void 0;\n  switch (scaleType) {\n\n    case 'tl':\n      caller = getTL;\n      break;\n\n    case 'ml':\n      caller = getML;\n      break;\n\n    case 'tr':\n      caller = getTR;\n      break;\n\n    case 'tm':\n      caller = getTM;\n      break;\n\n    case 'bl':\n      caller = getBL;\n      break;\n\n    case 'bm':\n      caller = getBM;\n      break;\n\n    case 'br':\n      caller = getBR;\n      break;\n\n    case 'mr':\n      caller = getMR;\n      break;\n  }\n\n  return caller(props);\n};\n\n/**\n * get sine and cosine for a point based on angle and point name\n *\n * @param {string} scaleType scale point position name\n * @param {number} angle the  rotation angle\n *\n * @returns {{sin: number, cos: number}} the sine and cosine of scale type\n */\nvar getSineCosine = exports.getSineCosine = function getSineCosine(scaleType, angle) {\n  switch (scaleType) {\n    case 'tr':\n    case 'tm':\n    case 'bl':\n    case 'bm':\n      return {\n        cos: Math.cos(-angle * (Math.PI / 180)),\n        sin: Math.sin(-angle * (Math.PI / 180))\n      };\n    default:\n      return {\n        sin: Math.sin(angle * (Math.PI / 180)),\n        cos: Math.cos(angle * (Math.PI / 180))\n      };\n  }\n};\n\n/**\n * get the amount of movement for a point\n *\n * @param {string} scaleType scale point position name\n * @param {object} oppositePoint the opposite point position {x: number,y: number}\n * @param {object} point the point position {x: number,y: number}\n * @param {object} moveDiff the the amount of pixels that element moved {x: number,y: number}\n *\n * @returns {{x: number, y:number}} the new position of moved element\n */\nvar getMovePoint = exports.getMovePoint = function getMovePoint(scaleType, oppositePoint, point, moveDiff) {\n  switch (scaleType) {\n\n    case 'tl':\n      return {\n        x: oppositePoint.x - (moveDiff.x + point.x),\n        y: oppositePoint.y - (moveDiff.y + point.y)\n      };\n    case 'ml':\n      return {\n        x: oppositePoint.x - moveDiff.x - point.x,\n        y: oppositePoint.y - moveDiff.y - point.y\n      };\n\n    case 'tr':\n    case 'tm':\n      return {\n        x: point.x + (moveDiff.x - oppositePoint.x),\n        y: oppositePoint.y - (moveDiff.y + point.y)\n      };\n    case 'mr':\n    case 'br':\n      return {\n        x: point.x + (moveDiff.x - oppositePoint.x),\n        y: point.y + (moveDiff.y - oppositePoint.y)\n      };\n    case 'bl':\n    case 'bm':\n      return {\n        x: oppositePoint.x - (moveDiff.x + point.x),\n        y: point.y + (moveDiff.y - oppositePoint.y)\n      };\n  }\n};\n\n/**\n * guess the original point position based on scale and the position after scaling\n *\n * @param {number} position the position of x or y\n * @param {number} size the size of element (width for x, height for y)\n * @param {number} scale the amount of scaled element (scaleX for x, scaleY for y)\n *\n * @returns {number} the original point position\n */\nvar getOriginalPositionFromScale = function getOriginalPositionFromScale(position, size, scale) {\n  var changed = size * scale;\n\n  var diff = changed - size;\n\n  return position - diff;\n};\n\n/***/ }),\n\n/***/ \"9b43\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(\"d8e8\");\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"9cdd\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.styler = exports.translate = exports.rotate = exports.scale = undefined;\n\nvar _scale = __webpack_require__(\"8675\");\n\nvar _scale2 = _interopRequireDefault(_scale);\n\nvar _rotate = __webpack_require__(\"927f\");\n\nvar _rotate2 = _interopRequireDefault(_rotate);\n\nvar _translate = __webpack_require__(\"2540\");\n\nvar _translate2 = _interopRequireDefault(_translate);\n\nvar _styler = __webpack_require__(\"89e1\");\n\nvar _styler2 = _interopRequireDefault(_styler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.scale = _scale2.default;\nexports.rotate = _rotate2.default;\nexports.translate = _translate2.default;\nexports.styler = _styler2.default;\n\n/***/ }),\n\n/***/ \"9def\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(\"4588\");\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"9e1e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"aa77\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(\"5ca1\");\nvar defined = __webpack_require__(\"be13\");\nvar fails = __webpack_require__(\"79e5\");\nvar spaces = __webpack_require__(\"fdef\");\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n\n\n/***/ }),\n\n/***/ \"be13\":\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"c366\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(\"6821\");\nvar toLength = __webpack_require__(\"9def\");\nvar toAbsoluteIndex = __webpack_require__(\"77f1\");\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ \"c5f6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(\"7726\");\nvar has = __webpack_require__(\"69a8\");\nvar cof = __webpack_require__(\"2d95\");\nvar inheritIfRequired = __webpack_require__(\"5dbc\");\nvar toPrimitive = __webpack_require__(\"6a99\");\nvar fails = __webpack_require__(\"79e5\");\nvar gOPN = __webpack_require__(\"9093\").f;\nvar gOPD = __webpack_require__(\"11e9\").f;\nvar dP = __webpack_require__(\"86cc\").f;\nvar $trim = __webpack_require__(\"aa77\").trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(__webpack_require__(\"2aeb\")(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = __webpack_require__(\"9e1e\") ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  __webpack_require__(\"2aba\")(global, NUMBER, $Number);\n}\n\n\n/***/ }),\n\n/***/ \"c69a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(\"9e1e\") && !__webpack_require__(\"79e5\")(function () {\n  return Object.defineProperty(__webpack_require__(\"230e\")('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"ca5a\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n\n/***/ \"cb7c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"d3f4\");\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"ce10\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"69a8\");\nvar toIObject = __webpack_require__(\"6821\");\nvar arrayIndexOf = __webpack_require__(\"c366\")(false);\nvar IE_PROTO = __webpack_require__(\"613b\")('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"d3f4\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"d8e8\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"e11e\":\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n\n/***/ \"fab2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(\"7726\").document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ \"fb15\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var setPublicPath_i\n  if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\\/)[^/]+\\.js$/))) {\n    __webpack_require__.p = setPublicPath_i[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\n/* harmony default export */ var setPublicPath = (null);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"2867f158-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/FreeTransform.vue?vue&type=template&id=7f510dfe&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:( _obj = {}, _obj[(_vm.classPrefix + \"-transform\")] = true, _obj[(_vm.classPrefix + \"-transform--active\")] = _vm.selected, _obj ),style:(_vm.styles),on:{\"click\":_vm.click,\"dblclick\":_vm.dblClick,\"mousedown\":_vm.mousedown}},[_c('div',{class:(_vm.classPrefix + \"-transform__content\"),style:(_vm.computedStyles.element)},[_vm._t(\"default\")],2),(_vm.selected)?_c('div',{class:(_vm.classPrefix + \"-transform__controls\"),style:(_vm.computedStyles.controls)},[_c('div',{class:(_vm.classPrefix + \"-transform__rotator\"),on:{\"mousedown\":_vm.handleRotation}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--tl\")],on:{\"mousedown\":function($event){_vm.handleScale('tl',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--ml\")],on:{\"mousedown\":function($event){_vm.handleScale('ml',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--tr\")],on:{\"mousedown\":function($event){_vm.handleScale('tr',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--tm\")],on:{\"mousedown\":function($event){_vm.handleScale('tm',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--bl\")],on:{\"mousedown\":function($event){_vm.handleScale('bl',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--bm\")],on:{\"mousedown\":function($event){_vm.handleScale('bm',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--br\")],on:{\"mousedown\":function($event){_vm.handleScale('br',$event)}}}),_c('div',{class:[(_vm.classPrefix + \"-transform__scale-point \" + _vm.classPrefix + \"-transform__scale-point--mr\")],on:{\"mousedown\":function($event){_vm.handleScale('mr',$event)}}})]):_vm._e()])\nvar _obj;}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/FreeTransform.vue?vue&type=template&id=7f510dfe&\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/builtin/es6/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/builtin/es6/objectSpread.js\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.number.constructor.js\nvar es6_number_constructor = __webpack_require__(\"c5f6\");\n\n// EXTERNAL MODULE: ./node_modules/free-transform/lib/index.js\nvar lib = __webpack_require__(\"9cdd\");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/FreeTransform.vue?vue&type=script&lang=js&\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var FreeTransformvue_type_script_lang_js_ = ({\n  name: 'Transform',\n  props: {\n    classPrefix: {\n      type: String,\n      default: \"tr\"\n    },\n    width: {\n      type: Number,\n      required: true\n    },\n    height: {\n      type: Number,\n      required: true\n    },\n    x: {\n      type: Number,\n      required: true\n    },\n    y: {\n      type: Number,\n      required: true\n    },\n    scaleX: {\n      type: Number,\n      required: true\n    },\n    scaleY: {\n      type: Number,\n      required: true\n    },\n    scaleLimit: {\n      type: Number,\n      default: 0.1\n    },\n    angle: {\n      type: Number,\n      required: true\n    },\n    disableScale: {\n      type: Boolean,\n      default: false\n    },\n    offsetX: {\n      type: Number,\n      required: true\n    },\n    offsetY: {\n      type: Number,\n      required: true\n    },\n    selected: {\n      type: Boolean,\n      default: true\n    },\n    styles: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    selectOn: {\n      validator: function validator(value) {\n        return ['dblclick', 'mousedown', 'click'].indexOf(value) !== -1;\n      },\n      default: 'mousedown'\n    },\n    aspectRatio: {\n      type: Boolean,\n      default: true\n    },\n    scaleFromCenter: {\n      type: Boolean,\n      default: true\n    }\n  },\n  computed: {\n    computedStyles: function computedStyles() {\n      var _styler = Object(lib[\"styler\"])({\n        x: this.x,\n        y: this.y,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        width: this.width,\n        height: this.height,\n        angle: this.angle,\n        disableScale: this.disableScale\n      }),\n          element = _styler.element,\n          controls = _styler.controls;\n\n      return {\n        element: _objectSpread({}, element, {\n          width: element.width ? \"\".concat(element.width, \"px\") : null,\n          height: element.height ? \"\".concat(element.height, \"px\") : null\n        }),\n        controls: _objectSpread({}, controls, {\n          width: \"\".concat(controls.width, \"px\"),\n          height: \"\".concat(controls.height, \"px\")\n        })\n      };\n    }\n  },\n  methods: {\n    handleScale: function handleScale(scaleType, event) {\n      var _this = this;\n\n      event.stopPropagation();\n      event.preventDefault();\n      var drag = Object(lib[\"scale\"])(scaleType, {\n        startX: event.pageX,\n        startY: event.pageY,\n        x: this.x,\n        y: this.y,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        width: this.width,\n        height: this.height,\n        angle: this.angle,\n        scaleLimit: this.scaleLimit,\n        scaleFromCenter: this.scaleFromCenter && event.altKey,\n        enableScaleFromCenter: this.scaleFromCenter,\n        aspectRatio: this.aspectRatio && event.shiftKey,\n        enableAspectRatio: this.aspectRatio\n      }, function (payload) {\n        _this.$emit(\"update\", payload);\n      });\n      this.onDrag(drag);\n    },\n    handleTranslation: function handleTranslation(event) {\n      var _this2 = this;\n\n      event.stopPropagation();\n      var drag = Object(lib[\"translate\"])({\n        x: this.x,\n        y: this.y,\n        startX: event.pageX,\n        startY: event.pageY\n      }, function (payload) {\n        _this2.$emit(\"update\", payload);\n      });\n      this.onDrag(drag);\n    },\n    handleRotation: function handleRotation(event) {\n      var _this3 = this;\n\n      event.stopPropagation();\n      var drag = Object(lib[\"rotate\"])({\n        startX: event.pageX,\n        startY: event.pageY,\n        x: this.x,\n        y: this.y,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        width: this.width,\n        height: this.height,\n        angle: this.angle,\n        offsetX: this.offsetX,\n        offsetY: this.offsetY\n      }, function (payload) {\n        _this3.$emit(\"update\", payload);\n      });\n      this.onDrag(drag);\n    },\n    onDrag: function onDrag(drag) {\n      var up = function up() {\n        document.removeEventListener('mousemove', drag);\n        document.removeEventListener('mouseup', up);\n      };\n\n      document.addEventListener('mousemove', drag);\n      document.addEventListener('mouseup', up);\n    },\n    mousedown: function mousedown(event) {\n      this.$emit(\"mousedown\", event);\n\n      if (this.selectOn === 'mousedown' || this.selected === true) {\n        this.$emit('onSelect');\n        this.handleTranslation(event);\n      }\n    },\n    click: function click(event) {\n      this.$emit('click', event);\n\n      if (this.selectOn === 'click') {\n        this.$emit('onSelect');\n      }\n    },\n    dblClick: function dblClick(event) {\n      this.$emit('dblclick', event);\n\n      if (this.selectOn === 'dblclick') {\n        this.$emit('onSelect');\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/FreeTransform.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_FreeTransformvue_type_script_lang_js_ = (FreeTransformvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/components/FreeTransform.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = normalizeComponent(\n  components_FreeTransformvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"FreeTransform.vue\"\n/* harmony default export */ var FreeTransform = (component.exports);\n// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n\n\n/* harmony default export */ var entry_lib = __webpack_exports__[\"default\"] = (FreeTransform);\n\n\n\n/***/ }),\n\n/***/ \"fdef\":\n/***/ (function(module, exports) {\n\nmodule.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\n/***/ })\n\n/******/ })[\"default\"];\n//# sourceMappingURL=FreeTransform.common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWZyZWUtdHJhbnNmb3JtL2Rpc3QvRnJlZVRyYW5zZm9ybS5jb21tb24uanM/MzI2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QTZCLCtCQUErQjtBQUMzakU7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQLFVBQVU7QUFDViIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtZnJlZS10cmFuc2Zvcm0vZGlzdC9GcmVlVHJhbnNmb3JtLmNvbW1vbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCJmYjE1XCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIjBkNThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2UxMFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlMTFlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMWU5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTJhN1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ2MzBcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY4MjFcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmE5OVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNjlhXCIpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMTQ5NVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODZjY1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjYjdjXCIpO1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGQ1OFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyMzBlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc3MjZcIikuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjI1NDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKF9yZWYsIG9uVXBkYXRlKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHN0YXJ0WCA9IF9yZWYuc3RhcnRYLFxuICAgICAgc3RhcnRZID0gX3JlZi5zdGFydFk7XG4gIHJldHVybiBmdW5jdGlvbiAoZHJhZ0V2ZW50KSB7XG5cbiAgICB4ICs9IGRyYWdFdmVudC5wYWdlWCAtIHN0YXJ0WDtcbiAgICB5ICs9IGRyYWdFdmVudC5wYWdlWSAtIHN0YXJ0WTtcblxuICAgIG9uVXBkYXRlKHsgeDogeCwgeTogeSB9KTtcblxuICAgIHN0YXJ0WCA9IGRyYWdFdmVudC5wYWdlWDtcbiAgICBzdGFydFkgPSBkcmFnRXZlbnQucGFnZVk7XG4gIH07XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNTViXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbiFmdW5jdGlvbihyLG4peyB0cnVlP21vZHVsZS5leHBvcnRzPW4oKTp1bmRlZmluZWR9KHdpbmRvdyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgbj17fTtmdW5jdGlvbiB0KGUpe2lmKG5bZV0pcmV0dXJuIG5bZV0uZXhwb3J0czt2YXIgbz1uW2VdPXtpOmUsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gcltlXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmw9ITAsby5leHBvcnRzfXJldHVybiB0Lm09cix0LmM9bix0LmQ9ZnVuY3Rpb24ocixuLGUpe3QubyhyLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkocixuLHtlbnVtZXJhYmxlOiEwLGdldDplfSl9LHQucj1mdW5jdGlvbihyKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24ocixuKXtpZigxJm4mJihyPXQocikpLDgmbilyZXR1cm4gcjtpZig0Jm4mJlwib2JqZWN0XCI9PXR5cGVvZiByJiZyJiZyLl9fZXNNb2R1bGUpcmV0dXJuIHI7dmFyIGU9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIoZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6cn0pLDImbiYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpZm9yKHZhciBvIGluIHIpdC5kKGUsbyxmdW5jdGlvbihuKXtyZXR1cm4gcltuXX0uYmluZChudWxsLG8pKTtyZXR1cm4gZX0sdC5uPWZ1bmN0aW9uKHIpe3ZhciBuPXImJnIuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24ocixuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsbil9LHQucD1cIlwiLHQodC5zPTApfShbZnVuY3Rpb24ocixuLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUocixuKXtyZXR1cm4gQXJyYXkuaXNBcnJheShuKT9bci5hKm5bMF0rci5jKm5bMV0rci5lLHIuYipuWzBdK3IuZCpuWzFdK3IuZl06e3g6ci5hKm4ueCtyLmMqbi55K3IuZSx5OnIuYipuLngrci5kKm4ueStyLmZ9fWZ1bmN0aW9uIG8ocixuKXtyZXR1cm4gbi5tYXAoZnVuY3Rpb24obil7cmV0dXJuIGUocixuKX0pfWZ1bmN0aW9uIHUocil7cmV0dXJue2E6cGFyc2VGbG9hdChyLmEpLGI6cGFyc2VGbG9hdChyLmIpLGM6cGFyc2VGbG9hdChyLmMpLGQ6cGFyc2VGbG9hdChyLmQpLGU6cGFyc2VGbG9hdChyLmUpLGY6cGFyc2VGbG9hdChyLmYpfX10LnIobik7dmFyIGE9L15tYXRyaXhcXChcXHMqKFswLTlfKy0uZV0rKVxccyosXFxzKihbMC05XystLmVdKylcXHMqLFxccyooWzAtOV8rLS5lXSspXFxzKixcXHMqKFswLTlfKy0uZV0rKVxccyosXFxzKihbMC05XystLmVdKylcXHMqLFxccyooWzAtOV8rLS5lXSspXFxzKlxcKSQvaTtmdW5jdGlvbiBpKHIpe3ZhciBuPXIubWF0Y2goYSk7aWYobnVsbD09PW58fG4ubGVuZ3RoPDcpdGhyb3cgbmV3IEVycm9yKFwiJ1wiK3IrXCInIGlzIG5vdCBhIG1hdHJpeFwiKTtyZXR1cm57YTpwYXJzZUZsb2F0KG5bMV0pLGI6cGFyc2VGbG9hdChuWzJdKSxjOnBhcnNlRmxvYXQoblszXSksZDpwYXJzZUZsb2F0KG5bNF0pLGU6cGFyc2VGbG9hdChuWzVdKSxmOnBhcnNlRmxvYXQobls2XSl9fWZ1bmN0aW9uIGYoKXtyZXR1cm57YToxLGM6MCxlOjAsYjowLGQ6MSxmOjB9fWZ1bmN0aW9uIGMocil7dmFyIG49ci5hLHQ9ci5iLGU9ci5jLG89ci5kLHU9ci5lLGE9ci5mLGk9bipvLXQqZTtyZXR1cm57YTpvL2ksYjp0Ly1pLGM6ZS8taSxkOm4vaSxlOihvKnUtZSphKS8taSxmOih0KnUtbiphKS9pfX12YXIgZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiByfTpmdW5jdGlvbihyKXtyZXR1cm4gciYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZyLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZyIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiByfSxzPWZ1bmN0aW9uKHIpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiByJiYhaXNOYU4ocikmJmlzRmluaXRlKHIpfSxsPWZ1bmN0aW9uKHIpe3JldHVybiBudWxsIT1yJiZcIm9iamVjdFwiPT09KHZvaWQgMD09PXI/XCJ1bmRlZmluZWRcIjpkKHIpKX07ZnVuY3Rpb24gcChyKXtyZXR1cm4gbChyKSYmci5oYXNPd25Qcm9wZXJ0eShcImFcIikmJnMoci5hKSYmci5oYXNPd25Qcm9wZXJ0eShcImJcIikmJnMoci5iKSYmci5oYXNPd25Qcm9wZXJ0eShcImNcIikmJnMoci5jKSYmci5oYXNPd25Qcm9wZXJ0eShcImRcIikmJnMoci5kKSYmci5oYXNPd25Qcm9wZXJ0eShcImVcIikmJnMoci5lKSYmci5oYXNPd25Qcm9wZXJ0eShcImZcIikmJnMoci5mKX1mdW5jdGlvbiB5KHIpe3JldHVybiB2b2lkIDA9PT1yfWZ1bmN0aW9uIGIocil7cmV0dXJue2E6MSxjOjAsZTpyLGI6MCxkOjEsZjphcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MH19ZnVuY3Rpb24gdigpe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLG49QXJyYXkociksdD0wO3Q8cjt0Kyspblt0XT1hcmd1bWVudHNbdF07dmFyIGU9ZnVuY3Rpb24ocixuKXtyZXR1cm57YTpyLmEqbi5hK3IuYypuLmIsYzpyLmEqbi5jK3IuYypuLmQsZTpyLmEqbi5lK3IuYypuLmYrci5lLGI6ci5iKm4uYStyLmQqbi5iLGQ6ci5iKm4uYytyLmQqbi5kLGY6ci5iKm4uZStyLmQqbi5mK3IuZn19O3N3aXRjaCgobj1BcnJheS5pc0FycmF5KG5bMF0pP25bMF06bikubGVuZ3RoKXtjYXNlIDA6dGhyb3cgbmV3IEVycm9yKFwibm8gbWF0cmljZXMgcHJvdmlkZWRcIik7Y2FzZSAxOnJldHVybiBuWzBdO2Nhc2UgMjpyZXR1cm4gZShuWzBdLG5bMV0pO2RlZmF1bHQ6dmFyIG89ZnVuY3Rpb24ocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocik/cjpBcnJheS5mcm9tKHIpfShuKSx1PW9bMF0sYT1vWzFdLGk9by5zbGljZSgyKSxmPWUodSxhKTtyZXR1cm4gdi5hcHBseSh2b2lkIDAsW2ZdLmNvbmNhdChmdW5jdGlvbihyKXtpZihBcnJheS5pc0FycmF5KHIpKXtmb3IodmFyIG49MCx0PUFycmF5KHIubGVuZ3RoKTtuPHIubGVuZ3RoO24rKyl0W25dPXJbbl07cmV0dXJuIHR9cmV0dXJuIEFycmF5LmZyb20ocil9KGkpKSl9fWZ1bmN0aW9uIG0oKXtyZXR1cm4gdi5hcHBseSh2b2lkIDAsYXJndW1lbnRzKX12YXIgaD1NYXRoLmNvcyx4PU1hdGguc2luLGc9TWF0aC5QSTtmdW5jdGlvbiB3KHIsbix0KXt2YXIgZT1oKHIpLG89eChyKSx1PXthOmUsYzotbyxlOjAsYjpvLGQ6ZSxmOjB9O3JldHVybiB5KG4pfHx5KHQpP3U6dihbYihuLHQpLHUsYigtbiwtdCldKX1mdW5jdGlvbiBQKHIpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp2b2lkIDAsdD1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3JldHVybiB3KHIqZy8xODAsbix0KX1mdW5jdGlvbiBTKHIpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp2b2lkIDA7cmV0dXJuIHkobikmJihuPXIpLHthOnIsYzowLGU6MCxiOjAsZDpuLGY6MH19ZnVuY3Rpb24gTyhyLG4pe3JldHVybnthOjEsYzpyLGU6MCxiOm4sZDoxLGY6MH19dmFyIEE9TWF0aC50YW47ZnVuY3Rpb24gRihyLG4pe3JldHVybnthOjEsYzpBKHIpLGU6MCxiOkEobiksZDoxLGY6MH19ZnVuY3Rpb24gTShyLG4pe3JldHVybiBGKHIqTWF0aC5QSS8xODAsbipNYXRoLlBJLzE4MCl9ZnVuY3Rpb24gaihyKXtyZXR1cm4gVChyKX1mdW5jdGlvbiBfKHIpe3JldHVybiBUKHIpfWZ1bmN0aW9uIFQocil7cmV0dXJuXCJtYXRyaXgoXCIrci5hK1wiLFwiK3IuYitcIixcIityLmMrXCIsXCIrci5kK1wiLFwiK3IuZStcIixcIityLmYrXCIpXCJ9dC5kKG4sXCJhcHBseVRvUG9pbnRcIixmdW5jdGlvbigpe3JldHVybiBlfSksdC5kKG4sXCJhcHBseVRvUG9pbnRzXCIsZnVuY3Rpb24oKXtyZXR1cm4gb30pLHQuZChuLFwiZnJvbU9iamVjdFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHV9KSx0LmQobixcImZyb21TdHJpbmdcIixmdW5jdGlvbigpe3JldHVybiBpfSksdC5kKG4sXCJpZGVudGl0eVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGZ9KSx0LmQobixcImludmVyc2VcIixmdW5jdGlvbigpe3JldHVybiBjfSksdC5kKG4sXCJpc0FmZmluZU1hdHJpeFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHB9KSx0LmQobixcInJvdGF0ZVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHd9KSx0LmQobixcInJvdGF0ZURFR1wiLGZ1bmN0aW9uKCl7cmV0dXJuIFB9KSx0LmQobixcInNjYWxlXCIsZnVuY3Rpb24oKXtyZXR1cm4gU30pLHQuZChuLFwic2hlYXJcIixmdW5jdGlvbigpe3JldHVybiBPfSksdC5kKG4sXCJza2V3XCIsZnVuY3Rpb24oKXtyZXR1cm4gRn0pLHQuZChuLFwic2tld0RFR1wiLGZ1bmN0aW9uKCl7cmV0dXJuIE19KSx0LmQobixcInRvQ1NTXCIsZnVuY3Rpb24oKXtyZXR1cm4gan0pLHQuZChuLFwidG9TVkdcIixmdW5jdGlvbigpe3JldHVybiBffSksdC5kKG4sXCJ0b1N0cmluZ1wiLGZ1bmN0aW9uKCl7cmV0dXJuIFR9KSx0LmQobixcInRyYW5zZm9ybVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KSx0LmQobixcImNvbXBvc2VcIixmdW5jdGlvbigpe3JldHVybiBtfSksdC5kKG4sXCJ0cmFuc2xhdGVcIixmdW5jdGlvbigpe3JldHVybiBifSl9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybWF0aW9uLW1hdHJpeC5taW4uanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJhYmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjlhOFwiKTtcbnZhciBTUkMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E1YVwiKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzNzhcIikuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyYWViXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgZFBzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE0OTVcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTExZVwiKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MTNiXCIpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMzBlXCIpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmFiMlwiKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMmQwMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJkOTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjMyZTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NjMwXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUxZVwiKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ1ODhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDYzMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUyYTdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNTUzN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmQwMFwiKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE4IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWNhMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc3MjZcIik7XG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4Mzc4XCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzJlOVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYWJhXCIpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5YjQzXCIpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1ZGJjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhiOTdcIikuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjEzYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU1MzdcIikoJ2tleXMnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2E1YVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2MjZhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjJkOTVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjgyMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYyNmFcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZTEzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2OWE4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmE5OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzcyNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzdmMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ODhcIik7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjc5ZTVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjgzNzhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS43JyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4Njc1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcG9pbnRGaW5kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTU5ZVwiKTtcblxuLyoqXG4gKiBQZXJmb3JtIFNjYWxpbmcgYmFzZWQgb24gYSBwb3NpdGlvbmVkIGhhbmRsZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZVR5cGUgc2NhbGUgcG9pbnQgcG9zaXRpb24gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgYW4gb2JqZWN0IGhvbGRpbmcgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc3RhcnRYIG1vdXNlIGRvd24gcG9zaXRpb24gb24gWCBheGlzXG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zdGFydFkgbW91c2UgZG93biBwb3NpdGlvbiBvbiBZIGF4aXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnggcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSBwb3NpdGlvbiBvZiB5XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zY2FsZVggYW1vdW50IG9mIHNjYWxlIGZvciB4ICh3aWR0aClcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnNjYWxlWSBhbW91bnQgb2Ygc2NhbGUgZm9yIHkgKGhlaWdodClcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLndpZHRoIG9yaWdpbmFsIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5oZWlnaHQgb3JpZ2luYWwgaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5hbmdsZSB0aGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnNjYWxlTGltaXQgbWluaW11bSBzY2FsZSBsaW1pdFxuICogQHBhcmFtIHtib29sZWFufSBwYXlsb2FkLnNjYWxlRnJvbUNlbnRlciBpcyBzY2FsZSBmcm9tIGNlbnRlclxuICogQHBhcmFtIHtib29sZWFufSBwYXlsb2FkLmFzcGVjdFJhdGlvIGlzIHNjYWxlIG9uIGFzcGVjdCByYXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVXBkYXRlIGEgY2FsbGJhY2sgb24gbW91c2UgdXBcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gZm9yIG1vdXNlIG1vdmVcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNjYWxlVHlwZSwgX3JlZiwgb25VcGRhdGUpIHtcbiAgdmFyIHN0YXJ0WCA9IF9yZWYuc3RhcnRYLFxuICAgICAgc3RhcnRZID0gX3JlZi5zdGFydFksXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHNjYWxlTGltaXQgPSBfcmVmLnNjYWxlTGltaXQsXG4gICAgICBfcmVmJHNjYWxlRnJvbUNlbnRlciA9IF9yZWYuc2NhbGVGcm9tQ2VudGVyLFxuICAgICAgc2NhbGVGcm9tQ2VudGVyID0gX3JlZiRzY2FsZUZyb21DZW50ZXIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzY2FsZUZyb21DZW50ZXIsXG4gICAgICBfcmVmJGVuYWJsZVNjYWxlRnJvbUMgPSBfcmVmLmVuYWJsZVNjYWxlRnJvbUNlbnRlcixcbiAgICAgIGVuYWJsZVNjYWxlRnJvbUNlbnRlciA9IF9yZWYkZW5hYmxlU2NhbGVGcm9tQyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkZW5hYmxlU2NhbGVGcm9tQyxcbiAgICAgIF9yZWYkYXNwZWN0UmF0aW8gPSBfcmVmLmFzcGVjdFJhdGlvLFxuICAgICAgYXNwZWN0UmF0aW8gPSBfcmVmJGFzcGVjdFJhdGlvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkYXNwZWN0UmF0aW8sXG4gICAgICBfcmVmJGVuYWJsZUFzcGVjdFJhdGkgPSBfcmVmLmVuYWJsZUFzcGVjdFJhdGlvLFxuICAgICAgZW5hYmxlQXNwZWN0UmF0aW8gPSBfcmVmJGVuYWJsZUFzcGVjdFJhdGkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJGVuYWJsZUFzcGVjdFJhdGk7XG5cblxuICB2YXIgcmF0aW8gPSB3aWR0aCAqIHNjYWxlWCAvIChoZWlnaHQgKiBzY2FsZVkpO1xuXG4gIHZhciBwb2ludCA9ICgwLCBfcG9pbnRGaW5kZXIuZ2V0UG9pbnQpKHNjYWxlVHlwZSwgeyB4OiB4LCB5OiB5LCBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGFuZ2xlOiBhbmdsZSwgc2NhbGVGcm9tQ2VudGVyOiBzY2FsZUZyb21DZW50ZXIgfSk7XG5cbiAgdmFyIG9wcG9zaXRlUG9pbnQgPSAoMCwgX3BvaW50RmluZGVyLmdldE9wcG9zaXRlUG9pbnQpKHNjYWxlVHlwZSwge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgYW5nbGU6IGFuZ2xlXG4gIH0pO1xuXG4gIHZhciBjdXJyZW50UHJvcHMgPSB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgaWYgKGVuYWJsZVNjYWxlRnJvbUNlbnRlciAmJiAoZXZlbnQuYWx0S2V5ICYmICFzY2FsZUZyb21DZW50ZXIgfHwgIWV2ZW50LmFsdEtleSAmJiBzY2FsZUZyb21DZW50ZXIpKSB7XG5cbiAgICAgIHN0YXJ0WCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgc3RhcnRZID0gZXZlbnQucGFnZVk7XG5cbiAgICAgIHNjYWxlRnJvbUNlbnRlciA9IGV2ZW50LmFsdEtleSAmJiAhc2NhbGVGcm9tQ2VudGVyO1xuXG4gICAgICBwb2ludCA9ICgwLCBfcG9pbnRGaW5kZXIuZ2V0UG9pbnQpKHNjYWxlVHlwZSwgX2V4dGVuZHMoe30sIGN1cnJlbnRQcm9wcywge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHNjYWxlRnJvbUNlbnRlcjogc2NhbGVGcm9tQ2VudGVyXG4gICAgICB9KSk7XG5cbiAgICAgIG9wcG9zaXRlUG9pbnQgPSAoMCwgX3BvaW50RmluZGVyLmdldE9wcG9zaXRlUG9pbnQpKHNjYWxlVHlwZSwgX2V4dGVuZHMoe30sIGN1cnJlbnRQcm9wcywge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBhbmdsZTogYW5nbGVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGFzcGVjdFJhdGlvKSB7XG4gICAgICBhc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgIWFzcGVjdFJhdGlvKSB7XG4gICAgICBhc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFlbmFibGVBc3BlY3RSYXRpbykge1xuICAgICAgYXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1vdmVEaWZmID0ge1xuICAgICAgeDogZXZlbnQucGFnZVggLSBzdGFydFgsXG4gICAgICB5OiBldmVudC5wYWdlWSAtIHN0YXJ0WVxuICAgIH07XG5cbiAgICB2YXIgbW92ZVBvaW50ID0gKDAsIF9wb2ludEZpbmRlci5nZXRNb3ZlUG9pbnQpKHNjYWxlVHlwZSwgb3Bwb3NpdGVQb2ludCwgcG9pbnQsIG1vdmVEaWZmKTtcblxuICAgIGlmIChlbmFibGVTY2FsZUZyb21DZW50ZXIgJiYgc2NhbGVGcm9tQ2VudGVyKSB7XG4gICAgICBtb3ZlUG9pbnQueCAqPSAyO1xuICAgICAgbW92ZVBvaW50LnkgKj0gMjtcbiAgICB9XG5cbiAgICB2YXIgX2dldFNpbmVDb3NpbmUgPSAoMCwgX3BvaW50RmluZGVyLmdldFNpbmVDb3NpbmUpKHNjYWxlVHlwZSwgYW5nbGUpLFxuICAgICAgICBzaW4gPSBfZ2V0U2luZUNvc2luZS5zaW4sXG4gICAgICAgIGNvcyA9IF9nZXRTaW5lQ29zaW5lLmNvcztcblxuICAgIHZhciByb3RhdGlvblBvaW50ID0ge1xuICAgICAgeDogbW92ZVBvaW50LnggKiBjb3MgKyBtb3ZlUG9pbnQueSAqIHNpbixcbiAgICAgIHk6IG1vdmVQb2ludC55ICogY29zIC0gbW92ZVBvaW50LnggKiBzaW5cbiAgICB9O1xuXG4gICAgY3VycmVudFByb3BzLnNjYWxlWCA9IHJvdGF0aW9uUG9pbnQueCAvIHdpZHRoID4gc2NhbGVMaW1pdCA/IHJvdGF0aW9uUG9pbnQueCAvIHdpZHRoIDogc2NhbGVMaW1pdDtcbiAgICBjdXJyZW50UHJvcHMuc2NhbGVZID0gcm90YXRpb25Qb2ludC55IC8gaGVpZ2h0ID4gc2NhbGVMaW1pdCA/IHJvdGF0aW9uUG9pbnQueSAvIGhlaWdodCA6IHNjYWxlTGltaXQ7XG5cbiAgICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgICAgY2FzZSAnbWwnOlxuICAgICAgY2FzZSAnbXInOlxuICAgICAgICBjdXJyZW50UHJvcHMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICBjdXJyZW50UHJvcHMuc2NhbGVZID0gd2lkdGggKiBjdXJyZW50UHJvcHMuc2NhbGVYICogKDEgLyByYXRpbykgLyBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0bSc6XG4gICAgICBjYXNlICdibSc6XG4gICAgICAgIGN1cnJlbnRQcm9wcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGN1cnJlbnRQcm9wcy5zY2FsZVggPSBoZWlnaHQgKiBjdXJyZW50UHJvcHMuc2NhbGVZICogcmF0aW8gLyB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgIGN1cnJlbnRQcm9wcy5zY2FsZVkgPSB3aWR0aCAqIGN1cnJlbnRQcm9wcy5zY2FsZVggKiAoMSAvIHJhdGlvKSAvIGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmFibGVTY2FsZUZyb21DZW50ZXIgJiYgc2NhbGVGcm9tQ2VudGVyKSB7XG4gICAgICB2YXIgY2VudGVyID0gKDAsIF9wb2ludEZpbmRlci5nZXRDZW50ZXIpKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBjdXJyZW50UHJvcHMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IGN1cnJlbnRQcm9wcy5zY2FsZVlcbiAgICAgIH0pO1xuICAgICAgY3VycmVudFByb3BzLnggPSB4ICsgKHBvaW50LnggLSBjZW50ZXIueCk7XG4gICAgICBjdXJyZW50UHJvcHMueSA9IHkgKyAocG9pbnQueSAtIGNlbnRlci55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyZXNoT3Bwb3NpdGVQb2ludCA9ICgwLCBfcG9pbnRGaW5kZXIuZ2V0T3Bwb3NpdGVQb2ludCkoc2NhbGVUeXBlLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgc2NhbGVYOiBjdXJyZW50UHJvcHMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IGN1cnJlbnRQcm9wcy5zY2FsZVlcbiAgICAgIH0pO1xuXG4gICAgICBjdXJyZW50UHJvcHMueCA9IHggKyAob3Bwb3NpdGVQb2ludC54IC0gZnJlc2hPcHBvc2l0ZVBvaW50LngpO1xuICAgICAgY3VycmVudFByb3BzLnkgPSB5ICsgKG9wcG9zaXRlUG9pbnQueSAtIGZyZXNoT3Bwb3NpdGVQb2ludC55KTtcbiAgICB9XG5cbiAgICBvblVwZGF0ZShjdXJyZW50UHJvcHMpO1xuICB9O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODZjY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2I3Y1wiKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNjlhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhOTlcIik7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODllMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RyYW5zZm9ybWF0aW9uTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI1NWJcIik7XG5cbi8vaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU3NjI3NjgvamF2YXNjcmlwdC1tYXRoLXJvdW5kLXRvLXR3by1kZWNpbWFsLXBsYWNlc1xudmFyIHJvdW5kVG8gPSBmdW5jdGlvbiByb3VuZFRvKG4pIHtcbiAgdmFyIGRpZ2l0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcblxuICB2YXIgbXVsdGlwbGljYXRvciA9IE1hdGgucG93KDEwLCBkaWdpdHMpO1xuICBuID0gcGFyc2VGbG9hdCgobiAqIG11bHRpcGxpY2F0b3IpLnRvRml4ZWQoMTEpKTtcbiAgdmFyIHRlc3QgPSBNYXRoLnJvdW5kKG4pIC8gbXVsdGlwbGljYXRvcjtcbiAgcmV0dXJuICt0ZXN0LnRvRml4ZWQoMik7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBhbmdsZSA9IF9yZWYuYW5nbGUsXG4gICAgICBzY2FsZVggPSBfcmVmLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBfcmVmJGRpc2FibGVTY2FsZSA9IF9yZWYuZGlzYWJsZVNjYWxlLFxuICAgICAgZGlzYWJsZVNjYWxlID0gX3JlZiRkaXNhYmxlU2NhbGUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRkaXNhYmxlU2NhbGU7XG5cblxuICB2YXIgY2hhbmdlZFdpZHRoID0gd2lkdGggKiAoMSAtIHNjYWxlWCk7XG4gIHZhciBuZXdXaWR0aCA9IHdpZHRoIC0gY2hhbmdlZFdpZHRoO1xuICB2YXIgY2hhbmdlZEhlaWdodCA9IGhlaWdodCAqICgxIC0gc2NhbGVZKTtcbiAgdmFyIG5ld0hlaWdodCA9IGhlaWdodCAtIGNoYW5nZWRIZWlnaHQ7XG5cbiAgdmFyIHRyYW5zZm9ybU1hdHJpeCA9IHZvaWQgMDtcblxuICBpZiAoZGlzYWJsZVNjYWxlID09PSBmYWxzZSkge1xuICAgIHRyYW5zZm9ybU1hdHJpeCA9ICgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgudHJhbnNmb3JtKSgoMCwgX3RyYW5zZm9ybWF0aW9uTWF0cml4LnRyYW5zbGF0ZSkocm91bmRUbyh4ICsgY2hhbmdlZFdpZHRoIC8gMiksIHJvdW5kVG8oeSArIGNoYW5nZWRIZWlnaHQgLyAyKSksICgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgucm90YXRlKShhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSksICgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXguc2NhbGUpKHNjYWxlWCwgc2NhbGVZKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNmb3JtTWF0cml4ID0gKDAsIF90cmFuc2Zvcm1hdGlvbk1hdHJpeC50cmFuc2Zvcm0pKCgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgudHJhbnNsYXRlKShyb3VuZFRvKHggKyBjaGFuZ2VkV2lkdGgpLCByb3VuZFRvKHkgKyBjaGFuZ2VkSGVpZ2h0KSksICgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgucm90YXRlKShhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSkpO1xuICAgIHdpZHRoID0gbmV3V2lkdGg7XG4gICAgaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHRyYW5zZm9ybTogKDAsIF90cmFuc2Zvcm1hdGlvbk1hdHJpeC50b0NTUykodHJhbnNmb3JtTWF0cml4KSxcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIGNvbnRyb2xzOiB7XG4gICAgICB3aWR0aDogbmV3V2lkdGgsXG4gICAgICBoZWlnaHQ6IG5ld0hlaWdodCxcbiAgICAgIHRyYW5zZm9ybTogKDAsIF90cmFuc2Zvcm1hdGlvbk1hdHJpeC50b0NTUykoKDAsIF90cmFuc2Zvcm1hdGlvbk1hdHJpeC50cmFuc2Zvcm0pKCgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgudHJhbnNsYXRlKShyb3VuZFRvKHggKyBjaGFuZ2VkV2lkdGgpLCByb3VuZFRvKHkgKyBjaGFuZ2VkSGVpZ2h0KSksICgwLCBfdHJhbnNmb3JtYXRpb25NYXRyaXgucm90YXRlKShhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSkpKSxcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9XG4gIH07XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4Yjk3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkM2Y0XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNiN2NcIik7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjliNDNcIikoRnVuY3Rpb24uY2FsbCwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIjExZTlcIikuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOTA5M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2UxMFwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUxMWVcIikuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkyN2ZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb2ludEZpbmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5NTllXCIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoX3JlZiwgb25VcGRhdGUpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgc2NhbGVYID0gX3JlZi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgc3RhcnRYID0gX3JlZi5zdGFydFgsXG4gICAgICBzdGFydFkgPSBfcmVmLnN0YXJ0WSxcbiAgICAgIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gX3JlZi5vZmZzZXRZO1xuXG5cbiAgdmFyIGNlbnRlciA9ICgwLCBfcG9pbnRGaW5kZXIuZ2V0Q2VudGVyKSh7IHg6IHgsIHk6IHksIHNjYWxlWDogc2NhbGVYLCBzY2FsZVk6IHNjYWxlWSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcblxuICB2YXIgcHJlc3NBbmdsZSA9IE1hdGguYXRhbjIoc3RhcnRZIC0gb2Zmc2V0WSAtIGNlbnRlci55LCBzdGFydFggLSBvZmZzZXRYIC0gY2VudGVyLngpICogMTgwIC8gTWF0aC5QSTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICB2YXIgZGVncmVlID0gTWF0aC5hdGFuMihldmVudC5wYWdlWSAtIG9mZnNldFkgLSBjZW50ZXIueSwgZXZlbnQucGFnZVggLSBvZmZzZXRYIC0gY2VudGVyLngpICogMTgwIC8gTWF0aC5QSTtcblxuICAgIHZhciBhbmcgPSBhbmdsZSArIGRlZ3JlZSAtIHByZXNzQW5nbGU7XG5cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGFuZyA9IChhbmcgLyAxNSA+PiAwKSAqIDE1O1xuICAgIH1cblxuICAgIG9uVXBkYXRlKHtcbiAgICAgIGFuZ2xlOiBhbmdcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk1OWVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBhY3R1YWwgcG9pbnQgcG9zaXRpb24gb2YgYSB0cmFuc2Zvcm1lZCBwb2ludFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIGFuIG9iamVjdCBob2xkaW5nIHJlcXVpcmVkIGluZm9ybWF0aW9uIHRvIGZpbmQgYWN0dWFsIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC54IHBvc2l0aW9uIG9mIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnkgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuYW5nbGUgdGhlICByb3RhdGlvbiBhbmdsZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQuY2VudGVyICB7e3gseX19IHRoZSBjZW50ZXIgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQucmFkIHRoZSBhIGNvbXB1dGVkIHJhZGlhbnMgb2YgYSBwcm92aWRlZCBhbmdsZVxuICpcbiAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBhbiBvYmplY3QgaG9sZGluZyB0aGUgcG9zaXRpb25cbiAqL1xudmFyIGZpbmRQb2ludCA9IGZ1bmN0aW9uIGZpbmRQb2ludChfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgX3JlZiRyYWQgPSBfcmVmLnJhZCxcbiAgICAgIHJhZCA9IF9yZWYkcmFkID09PSB1bmRlZmluZWQgPyBhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSA6IF9yZWYkcmFkO1xuICByZXR1cm4ge1xuICAgIHg6ICh4IC0gY2VudGVyLngpICogTWF0aC5jb3MocmFkKSAtICh5IC0gY2VudGVyLnkpICogTWF0aC5zaW4ocmFkKSArIGNlbnRlci54LFxuICAgIHk6ICh4IC0gY2VudGVyLngpICogTWF0aC5zaW4ocmFkKSArICh5IC0gY2VudGVyLnkpICogTWF0aC5jb3MocmFkKSArIGNlbnRlci55XG4gIH07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQ2VudGVyIHBvaW50IG9mIGEgYm94XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJucyB7e3g6ICosIHk6ICp9fSB0aGUgY2VudGVyIG9mIHBvaW50IG9mIGVsZW1lbnRcbiAqL1xudmFyIGdldENlbnRlciA9IGV4cG9ydHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyKF9yZWYyKSB7XG4gIHZhciB4ID0gX3JlZjIueCxcbiAgICAgIHkgPSBfcmVmMi55LFxuICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZjIuc2NhbGVZLFxuICAgICAgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcblxuICB2YXIgY2hhbmdlZFdpZHRoID0gd2lkdGggKiBzY2FsZVg7XG4gIHZhciBjaGFuZ2VkSGVpZ2h0ID0gaGVpZ2h0ICogc2NhbGVZO1xuXG4gIHZhciBjaGFuZ2VkV2lkdGhEaWZmID0gY2hhbmdlZFdpZHRoIC0gd2lkdGg7XG4gIHZhciBjaGFuZ2VkSGVpZ2h0RGlmZiA9IGNoYW5nZWRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4IC0gY2hhbmdlZFdpZHRoRGlmZiArIGNoYW5nZWRXaWR0aCAvIDIsXG4gICAgeTogeSAtIGNoYW5nZWRIZWlnaHREaWZmICsgY2hhbmdlZEhlaWdodCAvIDJcbiAgfTtcbn07XG5cbi8qKlxuICogZ2V0IHRoZSBUb3BMZWZ0IHBvaW50IHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkLmNlbnRlciB7e3g6bnVtYmVyLCB5Om51bWJlcn19XG4gKlxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBwb3NpdGlvblxuICovXG52YXIgZ2V0VEwgPSBleHBvcnRzLmdldFRMID0gZnVuY3Rpb24gZ2V0VEwoX3JlZjMpIHtcbiAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgeSA9IF9yZWYzLnksXG4gICAgICBzY2FsZVggPSBfcmVmMy5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmMy5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWYzLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmMy5hbmdsZSxcbiAgICAgIF9yZWYzJGNlbnRlciA9IF9yZWYzLmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWYzJGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjMkY2VudGVyO1xuICByZXR1cm4gZmluZFBvaW50KHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgYW5nbGU6IGFuZ2xlLFxuICAgIGNlbnRlcjogY2VudGVyXG4gIH0pO1xufTtcblxuLyoqXG4gKiBnZXQgdGhlIExlZnRCb3R0b20gcG9pbnQgcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBlbGVtZW50IGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC54IHRoZSBwb3NpdGlvbiBvZiB4XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC55IHRoZSBwb3NpdGlvbiBvZiB5XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zY2FsZVggdGhlIHNjYWxlWCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zY2FsZVkgdGhlIHNjYWxlWSBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC53aWR0aCB0aGUgb3JpZ2luYWwgd2lkdGggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuaGVpZ2h0IHRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuYW5nbGUgdGhlICByb3RhdGlvbiBhbmdsZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQuY2VudGVyIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqXG4gKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdGhlIHBvc2l0aW9uXG4gKi9cbnZhciBnZXRCTCA9IGV4cG9ydHMuZ2V0QkwgPSBmdW5jdGlvbiBnZXRCTChfcmVmNCkge1xuICB2YXIgeCA9IF9yZWY0LngsXG4gICAgICB5ID0gX3JlZjQueSxcbiAgICAgIHNjYWxlWCA9IF9yZWY0LnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWY0LnNjYWxlWSxcbiAgICAgIHdpZHRoID0gX3JlZjQud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmNC5oZWlnaHQsXG4gICAgICBhbmdsZSA9IF9yZWY0LmFuZ2xlLFxuICAgICAgX3JlZjQkY2VudGVyID0gX3JlZjQuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjQkY2VudGVyID09PSB1bmRlZmluZWQgPyBnZXRDZW50ZXIoeyB4OiB4LCB5OiB5LCBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSkgOiBfcmVmNCRjZW50ZXI7XG5cblxuICByZXR1cm4gZmluZFBvaW50KHtcbiAgICBhbmdsZTogYW5nbGUsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgeDogeCxcbiAgICB5OiB5ICsgaGVpZ2h0ICogc2NhbGVZXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgVG9wUmlnaHQgcG9pbnQgcG9zaXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBlbGVtZW50IGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC54IHRoZSBwb3NpdGlvbiBvZiB4XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC55IHRoZSBwb3NpdGlvbiBvZiB5XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zY2FsZVggdGhlIHNjYWxlWCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5zY2FsZVkgdGhlIHNjYWxlWSBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC53aWR0aCB0aGUgb3JpZ2luYWwgd2lkdGggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuaGVpZ2h0IHRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuYW5nbGUgdGhlICByb3RhdGlvbiBhbmdsZVxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQuY2VudGVyIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqXG4gKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gdGhlIHBvc2l0aW9uXG4gKi9cbnZhciBnZXRUUiA9IGV4cG9ydHMuZ2V0VFIgPSBmdW5jdGlvbiBnZXRUUihfcmVmNSkge1xuICB2YXIgeCA9IF9yZWY1LngsXG4gICAgICB5ID0gX3JlZjUueSxcbiAgICAgIHNjYWxlWCA9IF9yZWY1LnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWY1LnNjYWxlWSxcbiAgICAgIHdpZHRoID0gX3JlZjUud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmNS5oZWlnaHQsXG4gICAgICBhbmdsZSA9IF9yZWY1LmFuZ2xlLFxuICAgICAgX3JlZjUkY2VudGVyID0gX3JlZjUuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjUkY2VudGVyID09PSB1bmRlZmluZWQgPyBnZXRDZW50ZXIoeyB4OiB4LCB5OiB5LCBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSkgOiBfcmVmNSRjZW50ZXI7XG4gIHJldHVybiBmaW5kUG9pbnQoe1xuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICB4OiB4ICsgd2lkdGggKiBzY2FsZVgsXG4gICAgeTogeVxuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IEJvdHRvbVJpZ2h0IHBvaW50IHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkLmNlbnRlciB7e3g6bnVtYmVyLCB5Om51bWJlcn19XG4gKlxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBwb3NpdGlvblxuICovXG52YXIgZ2V0QlIgPSBleHBvcnRzLmdldEJSID0gZnVuY3Rpb24gZ2V0QlIoX3JlZjYpIHtcbiAgdmFyIHggPSBfcmVmNi54LFxuICAgICAgeSA9IF9yZWY2LnksXG4gICAgICBzY2FsZVggPSBfcmVmNi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmNi5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWY2LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmNi5hbmdsZSxcbiAgICAgIF9yZWY2JGNlbnRlciA9IF9yZWY2LmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWY2JGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjYkY2VudGVyO1xuXG4gIHJldHVybiBmaW5kUG9pbnQoe1xuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICB4OiB4ICsgd2lkdGggKiBzY2FsZVgsXG4gICAgeTogeSArIGhlaWdodCAqIHNjYWxlWVxuICB9KTtcbn07XG5cbi8qKlxuICogZ2V0IE1pZGRsZVJpZ2h0IHBvaW50IHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkLmNlbnRlciB7e3g6bnVtYmVyLCB5Om51bWJlcn19XG4gKlxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBwb3NpdGlvblxuICovXG52YXIgZ2V0TVIgPSBleHBvcnRzLmdldE1SID0gZnVuY3Rpb24gZ2V0TVIoX3JlZjcpIHtcbiAgdmFyIHggPSBfcmVmNy54LFxuICAgICAgeSA9IF9yZWY3LnksXG4gICAgICBzY2FsZVggPSBfcmVmNy5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmNy5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWY3LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjcuaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmNy5hbmdsZSxcbiAgICAgIF9yZWY3JGNlbnRlciA9IF9yZWY3LmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWY3JGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjckY2VudGVyO1xuICByZXR1cm4gZmluZFBvaW50KHtcbiAgICB4OiB4ICsgd2lkdGggKiBzY2FsZVgsXG4gICAgeTogeSArIGhlaWdodCAqIHNjYWxlWSAvIDIsXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgYW5nbGU6IGFuZ2xlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBnZXQgTWlkZGxlQm90dG9tIHBvaW50IHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkLmNlbnRlciB7e3g6bnVtYmVyLCB5Om51bWJlcn19XG4gKlxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBwb3NpdGlvblxuICovXG52YXIgZ2V0Qk0gPSBleHBvcnRzLmdldEJNID0gZnVuY3Rpb24gZ2V0Qk0oX3JlZjgpIHtcbiAgdmFyIHggPSBfcmVmOC54LFxuICAgICAgeSA9IF9yZWY4LnksXG4gICAgICBzY2FsZVggPSBfcmVmOC5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmOC5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWY4LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjguaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmOC5hbmdsZSxcbiAgICAgIF9yZWY4JGNlbnRlciA9IF9yZWY4LmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWY4JGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjgkY2VudGVyO1xuICByZXR1cm4gZmluZFBvaW50KHtcbiAgICB4OiB4ICsgd2lkdGggKiBzY2FsZVggLyAyLFxuICAgIHk6IHkgKyBoZWlnaHQgKiBzY2FsZVksXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgYW5nbGU6IGFuZ2xlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBnZXQgTWlkZGxlVG9wIHBvaW50IHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQueSB0aGUgcG9zaXRpb24gb2YgeVxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBheWxvYWQud2lkdGggdGhlIG9yaWdpbmFsIHdpZHRoIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkLmNlbnRlciB7e3g6bnVtYmVyLCB5Om51bWJlcn19XG4gKlxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHRoZSBwb3NpdGlvblxuICovXG52YXIgZ2V0VE0gPSBleHBvcnRzLmdldFRNID0gZnVuY3Rpb24gZ2V0VE0oX3JlZjkpIHtcbiAgdmFyIHggPSBfcmVmOS54LFxuICAgICAgeSA9IF9yZWY5LnksXG4gICAgICBzY2FsZVggPSBfcmVmOS5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmOS5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWY5LndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZjkuaGVpZ2h0LFxuICAgICAgYW5nbGUgPSBfcmVmOS5hbmdsZSxcbiAgICAgIF9yZWY5JGNlbnRlciA9IF9yZWY5LmNlbnRlcixcbiAgICAgIGNlbnRlciA9IF9yZWY5JGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjkkY2VudGVyO1xuICByZXR1cm4gZmluZFBvaW50KHtcbiAgICB4OiB4ICsgd2lkdGggKiBzY2FsZVggLyAyLFxuICAgIHk6IHksXG4gICAgY2VudGVyOiBjZW50ZXIsXG4gICAgYW5nbGU6IGFuZ2xlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBnZXQgTWlkZGxlTGVmdCBwb2ludCBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIGVsZW1lbnQgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnggdGhlIHBvc2l0aW9uIG9mIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnkgdGhlIHBvc2l0aW9uIG9mIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnNjYWxlWCB0aGUgc2NhbGVYIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLnNjYWxlWSB0aGUgc2NhbGVZIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXlsb2FkLndpZHRoIHRoZSBvcmlnaW5hbCB3aWR0aCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5oZWlnaHQgdGhlIG9yaWdpbmFsIGhlaWdodCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGF5bG9hZC5hbmdsZSB0aGUgIHJvdGF0aW9uIGFuZ2xlXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZC5jZW50ZXIge3t4Om51bWJlciwgeTpudW1iZXJ9fVxuICpcbiAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0aGUgcG9zaXRpb25cbiAqL1xudmFyIGdldE1MID0gZXhwb3J0cy5nZXRNTCA9IGZ1bmN0aW9uIGdldE1MKF9yZWYxMCkge1xuICB2YXIgeCA9IF9yZWYxMC54LFxuICAgICAgeSA9IF9yZWYxMC55LFxuICAgICAgc2NhbGVYID0gX3JlZjEwLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYxMC5zY2FsZVksXG4gICAgICB3aWR0aCA9IF9yZWYxMC53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYxMC5oZWlnaHQsXG4gICAgICBhbmdsZSA9IF9yZWYxMC5hbmdsZSxcbiAgICAgIF9yZWYxMCRjZW50ZXIgPSBfcmVmMTAuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjEwJGNlbnRlciA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKHsgeDogeCwgeTogeSwgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pIDogX3JlZjEwJGNlbnRlcjtcbiAgcmV0dXJuIGZpbmRQb2ludCh7XG4gICAgeDogeCxcbiAgICB5OiB5ICsgaGVpZ2h0ICogc2NhbGVZIC8gMixcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBhbmdsZTogYW5nbGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIGdpdmVuIGEgcG9pbnQsIGdldCBpdCdzIG9wcG9zaXRlIHBvaW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlVHlwZSBzY2FsZSBwb2ludCBwb3NpdGlvbiBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgZWxlbWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnggdGhlIHBvc2l0aW9uIG9mIHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy55IHRoZSBwb3NpdGlvbiBvZiB5XG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMuc2NhbGVYIHRoZSBzY2FsZVggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnNjYWxlWSB0aGUgc2NhbGVZIG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy53aWR0aCB0aGUgb3JpZ2luYWwgd2lkdGggb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLmhlaWdodCB0aGUgb3JpZ2luYWwgaGVpZ2h0IG9mIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5hbmdsZSB0aGUgIHJvdGF0aW9uIGFuZ2xlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMuY2VudGVyIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqXG4gKiBAcmV0dXJucyB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50IHBvc2l0aW9uXG4gKi9cbnZhciBnZXRPcHBvc2l0ZVBvaW50ID0gZXhwb3J0cy5nZXRPcHBvc2l0ZVBvaW50ID0gZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQb2ludChzY2FsZVR5cGUsIHByb3BzKSB7XG5cbiAgdmFyIGNhbGxlciA9IHZvaWQgMDtcblxuICB2YXIgY2VudGVyID0gZ2V0Q2VudGVyKHtcbiAgICB4OiBwcm9wcy54LFxuICAgIHk6IHByb3BzLnksXG4gICAgd2lkdGg6IHByb3BzLndpZHRoLFxuICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgIHNjYWxlWDogcHJvcHMuc2NhbGVYLFxuICAgIHNjYWxlWTogcHJvcHMuc2NhbGVZXG4gIH0pO1xuXG4gIHByb3BzID0gX2V4dGVuZHMoe1xuICAgIGNlbnRlcjogY2VudGVyXG4gIH0sIHByb3BzLCB7XG4gICAgeDogZ2V0T3JpZ2luYWxQb3NpdGlvbkZyb21TY2FsZShwcm9wcy54LCBwcm9wcy53aWR0aCwgcHJvcHMuc2NhbGVYKSxcbiAgICB5OiBnZXRPcmlnaW5hbFBvc2l0aW9uRnJvbVNjYWxlKHByb3BzLnksIHByb3BzLmhlaWdodCwgcHJvcHMuc2NhbGVZKVxuICB9KTtcblxuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgJ3RsJzpcbiAgICAgIGNhbGxlciA9IGdldEJSO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtbCc6XG4gICAgICBjYWxsZXIgPSBnZXRNUjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndHInOlxuICAgICAgY2FsbGVyID0gZ2V0Qkw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RtJzpcbiAgICAgIGNhbGxlciA9IGdldEJNO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdibCc6XG4gICAgICBjYWxsZXIgPSBnZXRUUjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm0nOlxuICAgICAgY2FsbGVyID0gZ2V0VE07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JyJzpcbiAgICAgIGNhbGxlciA9IGdldFRMO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtcic6XG4gICAgICBjYWxsZXIgPSBnZXRNTDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjYWxsZXIocHJvcHMpO1xufTtcblxuLyoqXG4gKiBnaXZlbiBhIHBvaW50IHBvc2l0aW9uIGJ5IGl0J3Mgc3RyaW5nIG5hbWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVUeXBlIHNjYWxlIHBvaW50IHBvc2l0aW9uIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBlbGVtZW50IGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMueCB0aGUgcG9zaXRpb24gb2YgeFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLnkgdGhlIHBvc2l0aW9uIG9mIHlcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zY2FsZVggdGhlIHNjYWxlWCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMuc2NhbGVZIHRoZSBzY2FsZVkgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLndpZHRoIHRoZSBvcmlnaW5hbCB3aWR0aCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcHMuaGVpZ2h0IHRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHByb3BzLmFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcHMuc2NhbGVGcm9tQ2VudGVyIHNjYWxpbmcgcGVyZm9ybWVkIGZyb20gY2VudGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMuY2VudGVyIHt7eDpudW1iZXIsIHk6bnVtYmVyfX1cbiAqXG4gKiBAcmV0dXJucyB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50IHBvc2l0aW9uXG4gKi9cbnZhciBnZXRQb2ludCA9IGV4cG9ydHMuZ2V0UG9pbnQgPSBmdW5jdGlvbiBnZXRQb2ludChzY2FsZVR5cGUsIHByb3BzKSB7XG5cbiAgdmFyIGNlbnRlciA9IGdldENlbnRlcih7XG4gICAgeDogcHJvcHMueCxcbiAgICB5OiBwcm9wcy55LFxuICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICBzY2FsZVg6IHByb3BzLnNjYWxlWCxcbiAgICBzY2FsZVk6IHByb3BzLnNjYWxlWVxuICB9KTtcblxuICBpZiAocHJvcHMuc2NhbGVGcm9tQ2VudGVyKSB7XG4gICAgcmV0dXJuIGNlbnRlcjtcbiAgfVxuXG4gIHByb3BzID0gX2V4dGVuZHMoe1xuICAgIGNlbnRlcjogY2VudGVyXG4gIH0sIHByb3BzLCB7XG4gICAgeDogZ2V0T3JpZ2luYWxQb3NpdGlvbkZyb21TY2FsZShwcm9wcy54LCBwcm9wcy53aWR0aCwgcHJvcHMuc2NhbGVYKSxcbiAgICB5OiBnZXRPcmlnaW5hbFBvc2l0aW9uRnJvbVNjYWxlKHByb3BzLnksIHByb3BzLmhlaWdodCwgcHJvcHMuc2NhbGVZKVxuICB9KTtcblxuICB2YXIgY2FsbGVyID0gdm9pZCAwO1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuXG4gICAgY2FzZSAndGwnOlxuICAgICAgY2FsbGVyID0gZ2V0VEw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21sJzpcbiAgICAgIGNhbGxlciA9IGdldE1MO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0cic6XG4gICAgICBjYWxsZXIgPSBnZXRUUjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndG0nOlxuICAgICAgY2FsbGVyID0gZ2V0VE07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JsJzpcbiAgICAgIGNhbGxlciA9IGdldEJMO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdibSc6XG4gICAgICBjYWxsZXIgPSBnZXRCTTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYnInOlxuICAgICAgY2FsbGVyID0gZ2V0QlI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21yJzpcbiAgICAgIGNhbGxlciA9IGdldE1SO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gY2FsbGVyKHByb3BzKTtcbn07XG5cbi8qKlxuICogZ2V0IHNpbmUgYW5kIGNvc2luZSBmb3IgYSBwb2ludCBiYXNlZCBvbiBhbmdsZSBhbmQgcG9pbnQgbmFtZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZVR5cGUgc2NhbGUgcG9pbnQgcG9zaXRpb24gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIHRoZSAgcm90YXRpb24gYW5nbGVcbiAqXG4gKiBAcmV0dXJucyB7e3NpbjogbnVtYmVyLCBjb3M6IG51bWJlcn19IHRoZSBzaW5lIGFuZCBjb3NpbmUgb2Ygc2NhbGUgdHlwZVxuICovXG52YXIgZ2V0U2luZUNvc2luZSA9IGV4cG9ydHMuZ2V0U2luZUNvc2luZSA9IGZ1bmN0aW9uIGdldFNpbmVDb3NpbmUoc2NhbGVUeXBlLCBhbmdsZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgJ3RyJzpcbiAgICBjYXNlICd0bSc6XG4gICAgY2FzZSAnYmwnOlxuICAgIGNhc2UgJ2JtJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvczogTWF0aC5jb3MoLWFuZ2xlICogKE1hdGguUEkgLyAxODApKSxcbiAgICAgICAgc2luOiBNYXRoLnNpbigtYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaW46IE1hdGguc2luKGFuZ2xlICogKE1hdGguUEkgLyAxODApKSxcbiAgICAgICAgY29zOiBNYXRoLmNvcyhhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSlcbiAgICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IHRoZSBhbW91bnQgb2YgbW92ZW1lbnQgZm9yIGEgcG9pbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NhbGVUeXBlIHNjYWxlIHBvaW50IHBvc2l0aW9uIG5hbWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHBvc2l0ZVBvaW50IHRoZSBvcHBvc2l0ZSBwb2ludCBwb3NpdGlvbiB7eDogbnVtYmVyLHk6IG51bWJlcn1cbiAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCB0aGUgcG9pbnQgcG9zaXRpb24ge3g6IG51bWJlcix5OiBudW1iZXJ9XG4gKiBAcGFyYW0ge29iamVjdH0gbW92ZURpZmYgdGhlIHRoZSBhbW91bnQgb2YgcGl4ZWxzIHRoYXQgZWxlbWVudCBtb3ZlZCB7eDogbnVtYmVyLHk6IG51bWJlcn1cbiAqXG4gKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTpudW1iZXJ9fSB0aGUgbmV3IHBvc2l0aW9uIG9mIG1vdmVkIGVsZW1lbnRcbiAqL1xudmFyIGdldE1vdmVQb2ludCA9IGV4cG9ydHMuZ2V0TW92ZVBvaW50ID0gZnVuY3Rpb24gZ2V0TW92ZVBvaW50KHNjYWxlVHlwZSwgb3Bwb3NpdGVQb2ludCwgcG9pbnQsIG1vdmVEaWZmKSB7XG4gIHN3aXRjaCAoc2NhbGVUeXBlKSB7XG5cbiAgICBjYXNlICd0bCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBvcHBvc2l0ZVBvaW50LnggLSAobW92ZURpZmYueCArIHBvaW50LngpLFxuICAgICAgICB5OiBvcHBvc2l0ZVBvaW50LnkgLSAobW92ZURpZmYueSArIHBvaW50LnkpXG4gICAgICB9O1xuICAgIGNhc2UgJ21sJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IG9wcG9zaXRlUG9pbnQueCAtIG1vdmVEaWZmLnggLSBwb2ludC54LFxuICAgICAgICB5OiBvcHBvc2l0ZVBvaW50LnkgLSBtb3ZlRGlmZi55IC0gcG9pbnQueVxuICAgICAgfTtcblxuICAgIGNhc2UgJ3RyJzpcbiAgICBjYXNlICd0bSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludC54ICsgKG1vdmVEaWZmLnggLSBvcHBvc2l0ZVBvaW50LngpLFxuICAgICAgICB5OiBvcHBvc2l0ZVBvaW50LnkgLSAobW92ZURpZmYueSArIHBvaW50LnkpXG4gICAgICB9O1xuICAgIGNhc2UgJ21yJzpcbiAgICBjYXNlICdicic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludC54ICsgKG1vdmVEaWZmLnggLSBvcHBvc2l0ZVBvaW50LngpLFxuICAgICAgICB5OiBwb2ludC55ICsgKG1vdmVEaWZmLnkgLSBvcHBvc2l0ZVBvaW50LnkpXG4gICAgICB9O1xuICAgIGNhc2UgJ2JsJzpcbiAgICBjYXNlICdibSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBvcHBvc2l0ZVBvaW50LnggLSAobW92ZURpZmYueCArIHBvaW50LngpLFxuICAgICAgICB5OiBwb2ludC55ICsgKG1vdmVEaWZmLnkgLSBvcHBvc2l0ZVBvaW50LnkpXG4gICAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIGd1ZXNzIHRoZSBvcmlnaW5hbCBwb2ludCBwb3NpdGlvbiBiYXNlZCBvbiBzY2FsZSBhbmQgdGhlIHBvc2l0aW9uIGFmdGVyIHNjYWxpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHggb3IgeVxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIHNpemUgb2YgZWxlbWVudCAod2lkdGggZm9yIHgsIGhlaWdodCBmb3IgeSlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IG9mIHNjYWxlZCBlbGVtZW50IChzY2FsZVggZm9yIHgsIHNjYWxlWSBmb3IgeSlcbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgb3JpZ2luYWwgcG9pbnQgcG9zaXRpb25cbiAqL1xudmFyIGdldE9yaWdpbmFsUG9zaXRpb25Gcm9tU2NhbGUgPSBmdW5jdGlvbiBnZXRPcmlnaW5hbFBvc2l0aW9uRnJvbVNjYWxlKHBvc2l0aW9uLCBzaXplLCBzY2FsZSkge1xuICB2YXIgY2hhbmdlZCA9IHNpemUgKiBzY2FsZTtcblxuICB2YXIgZGlmZiA9IGNoYW5nZWQgLSBzaXplO1xuXG4gIHJldHVybiBwb3NpdGlvbiAtIGRpZmY7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5YjQzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkOGU4XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjljZGRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3R5bGVyID0gZXhwb3J0cy50cmFuc2xhdGUgPSBleHBvcnRzLnJvdGF0ZSA9IGV4cG9ydHMuc2NhbGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfc2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODY3NVwiKTtcblxudmFyIF9zY2FsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY2FsZSk7XG5cbnZhciBfcm90YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjkyN2ZcIik7XG5cbnZhciBfcm90YXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdGF0ZSk7XG5cbnZhciBfdHJhbnNsYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI1NDBcIik7XG5cbnZhciBfdHJhbnNsYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RyYW5zbGF0ZSk7XG5cbnZhciBfc3R5bGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg5ZTFcIik7XG5cbnZhciBfc3R5bGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0eWxlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuc2NhbGUgPSBfc2NhbGUyLmRlZmF1bHQ7XG5leHBvcnRzLnJvdGF0ZSA9IF9yb3RhdGUyLmRlZmF1bHQ7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IF90cmFuc2xhdGUyLmRlZmF1bHQ7XG5leHBvcnRzLnN0eWxlciA9IF9zdHlsZXIyLmRlZmF1bHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjlkZWZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1ODhcIik7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZTFlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhYTc3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVjYTFcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZTEzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc5ZTVcIik7XG52YXIgc3BhY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZkZWZcIik7XG52YXIgc3BhY2UgPSAnWycgKyBzcGFjZXMgKyAnXSc7XG52YXIgbm9uID0gJ1xcdTIwMGJcXHUwMDg1JztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEFMSUFTKSB7XG4gIHZhciBleHAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZiAoQUxJQVMpIGV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbiAoc3RyaW5nLCBUWVBFKSB7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYmUxM1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMzNjZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjgyMVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZGVmXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3N2YxXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzVmNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OWE4XCIpO1xudmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyZDk1XCIpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVkYmNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmE5OVwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OWU1XCIpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTA5M1wiKS5mO1xudmFyIGdPUEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTFlOVwiKS5mO1xudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2Y2NcIikuZjtcbnZhciAkdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYTc3XCIpLnRyaW07XG52YXIgTlVNQkVSID0gJ051bWJlcic7XG52YXIgJE51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIEJhc2UgPSAkTnVtYmVyO1xudmFyIHByb3RvID0gJE51bWJlci5wcm90b3R5cGU7XG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ09GID0gY29mKF9fd2VicGFja19yZXF1aXJlX18oXCIyYWViXCIpKHByb3RvKSkgPT0gTlVNQkVSO1xudmFyIFRSSU0gPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZiAoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKSB7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24gKCkgeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspIHtcbiAgICBpZiAoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSkge1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIF9fd2VicGFja19yZXF1aXJlX18oXCIyYWJhXCIpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNjlhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oXCI5ZTFlXCIpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzllNVwiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIzMGVcIikoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNhNWFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2I3Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNmNFwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2UxMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY5YThcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjY4MjFcIik7XG52YXIgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMzNjZcIikoZmFsc2UpO1xudmFyIElFX1BST1RPID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYxM2JcIikoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQzZjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDhlOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTExZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYWIyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NzI2XCIpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmIxNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHZ1ZS9jbGktc2VydmljZS9saWIvY29tbWFuZHMvYnVpbGQvc2V0UHVibGljUGF0aC5qc1xuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGludG8gbGliL3djIGNsaWVudCBidW5kbGVzLlxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHNldFB1YmxpY1BhdGhfaVxuICBpZiAoKHNldFB1YmxpY1BhdGhfaSA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0KSAmJiAoc2V0UHVibGljUGF0aF9pID0gc2V0UHVibGljUGF0aF9pLnNyYy5tYXRjaCgvKC4rXFwvKVteL10rXFwuanMkLykpKSB7XG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2V0UHVibGljUGF0aF9pWzFdIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgfVxufVxuXG4vLyBJbmRpY2F0ZSB0byB3ZWJwYWNrIHRoYXQgdGhpcyBmaWxlIGNhbiBiZSBjb25jYXRlbmF0ZWRcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNldFB1YmxpY1BhdGggPSAobnVsbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjI4NjdmMTU4LXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9jb21wb25lbnRzL0ZyZWVUcmFuc2Zvcm0udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTdmNTEwZGZlJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse2NsYXNzOiggX29iaiA9IHt9LCBfb2JqWyhfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1cIildID0gdHJ1ZSwgX29ialsoX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtLS1hY3RpdmVcIildID0gX3ZtLnNlbGVjdGVkLCBfb2JqICksc3R5bGU6KF92bS5zdHlsZXMpLG9uOntcImNsaWNrXCI6X3ZtLmNsaWNrLFwiZGJsY2xpY2tcIjpfdm0uZGJsQ2xpY2ssXCJtb3VzZWRvd25cIjpfdm0ubW91c2Vkb3dufX0sW19jKCdkaXYnLHtjbGFzczooX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19jb250ZW50XCIpLHN0eWxlOihfdm0uY29tcHV0ZWRTdHlsZXMuZWxlbWVudCl9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKSwoX3ZtLnNlbGVjdGVkKT9fYygnZGl2Jyx7Y2xhc3M6KF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fY29udHJvbHNcIiksc3R5bGU6KF92bS5jb21wdXRlZFN0eWxlcy5jb250cm9scyl9LFtfYygnZGl2Jyx7Y2xhc3M6KF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fcm90YXRvclwiKSxvbjp7XCJtb3VzZWRvd25cIjpfdm0uaGFuZGxlUm90YXRpb259fSksX2MoJ2Rpdicse2NsYXNzOlsoX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19zY2FsZS1wb2ludCBcIiArIF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQtLXRsXCIpXSxvbjp7XCJtb3VzZWRvd25cIjpmdW5jdGlvbigkZXZlbnQpe192bS5oYW5kbGVTY2FsZSgndGwnLCRldmVudCl9fX0pLF9jKCdkaXYnLHtjbGFzczpbKF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQgXCIgKyBfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1fX3NjYWxlLXBvaW50LS1tbFwiKV0sb246e1wibW91c2Vkb3duXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaGFuZGxlU2NhbGUoJ21sJywkZXZlbnQpfX19KSxfYygnZGl2Jyx7Y2xhc3M6Wyhfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1fX3NjYWxlLXBvaW50IFwiICsgX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19zY2FsZS1wb2ludC0tdHJcIildLG9uOntcIm1vdXNlZG93blwiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLmhhbmRsZVNjYWxlKCd0cicsJGV2ZW50KX19fSksX2MoJ2Rpdicse2NsYXNzOlsoX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19zY2FsZS1wb2ludCBcIiArIF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQtLXRtXCIpXSxvbjp7XCJtb3VzZWRvd25cIjpmdW5jdGlvbigkZXZlbnQpe192bS5oYW5kbGVTY2FsZSgndG0nLCRldmVudCl9fX0pLF9jKCdkaXYnLHtjbGFzczpbKF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQgXCIgKyBfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1fX3NjYWxlLXBvaW50LS1ibFwiKV0sb246e1wibW91c2Vkb3duXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaGFuZGxlU2NhbGUoJ2JsJywkZXZlbnQpfX19KSxfYygnZGl2Jyx7Y2xhc3M6Wyhfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1fX3NjYWxlLXBvaW50IFwiICsgX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19zY2FsZS1wb2ludC0tYm1cIildLG9uOntcIm1vdXNlZG93blwiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLmhhbmRsZVNjYWxlKCdibScsJGV2ZW50KX19fSksX2MoJ2Rpdicse2NsYXNzOlsoX3ZtLmNsYXNzUHJlZml4ICsgXCItdHJhbnNmb3JtX19zY2FsZS1wb2ludCBcIiArIF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQtLWJyXCIpXSxvbjp7XCJtb3VzZWRvd25cIjpmdW5jdGlvbigkZXZlbnQpe192bS5oYW5kbGVTY2FsZSgnYnInLCRldmVudCl9fX0pLF9jKCdkaXYnLHtjbGFzczpbKF92bS5jbGFzc1ByZWZpeCArIFwiLXRyYW5zZm9ybV9fc2NhbGUtcG9pbnQgXCIgKyBfdm0uY2xhc3NQcmVmaXggKyBcIi10cmFuc2Zvcm1fX3NjYWxlLXBvaW50LS1tclwiKV0sb246e1wibW91c2Vkb3duXCI6ZnVuY3Rpb24oJGV2ZW50KXtfdm0uaGFuZGxlU2NhbGUoJ21yJywkZXZlbnQpfX19KV0pOl92bS5fZSgpXSlcbnZhciBfb2JqO31cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvRnJlZVRyYW5zZm9ybS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2Y1MTBkZmUmXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYnVpbHRpbi9lczYvZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9idWlsdGluL2VzNi9vYmplY3RTcHJlYWQuanNcblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbnZhciBlczZfbnVtYmVyX2NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1ZjZcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvZnJlZS10cmFuc2Zvcm0vbGliL2luZGV4LmpzXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjljZGRcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvY29tcG9uZW50cy9GcmVlVHJhbnNmb3JtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIEZyZWVUcmFuc2Zvcm12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnVHJhbnNmb3JtJyxcbiAgcHJvcHM6IHtcbiAgICBjbGFzc1ByZWZpeDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogXCJ0clwiXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgc2NhbGVYOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgc2NhbGVZOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgc2NhbGVMaW1pdDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGRpc2FibGVTY2FsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBvZmZzZXRYOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgb2Zmc2V0WToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgc3R5bGVzOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0T246IHtcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdjbGljayddLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiAnbW91c2Vkb3duJ1xuICAgIH0sXG4gICAgYXNwZWN0UmF0aW86IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBzY2FsZUZyb21DZW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNvbXB1dGVkU3R5bGVzOiBmdW5jdGlvbiBjb21wdXRlZFN0eWxlcygpIHtcbiAgICAgIHZhciBfc3R5bGVyID0gT2JqZWN0KGxpYltcInN0eWxlclwiXSkoe1xuICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICBkaXNhYmxlU2NhbGU6IHRoaXMuZGlzYWJsZVNjYWxlXG4gICAgICB9KSxcbiAgICAgICAgICBlbGVtZW50ID0gX3N0eWxlci5lbGVtZW50LFxuICAgICAgICAgIGNvbnRyb2xzID0gX3N0eWxlci5jb250cm9scztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudDogX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCwge1xuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoID8gXCJcIi5jb25jYXQoZWxlbWVudC53aWR0aCwgXCJweFwiKSA6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCA/IFwiXCIuY29uY2F0KGVsZW1lbnQuaGVpZ2h0LCBcInB4XCIpIDogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgY29udHJvbHM6IF9vYmplY3RTcHJlYWQoe30sIGNvbnRyb2xzLCB7XG4gICAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KGNvbnRyb2xzLndpZHRoLCBcInB4XCIpLFxuICAgICAgICAgIGhlaWdodDogXCJcIi5jb25jYXQoY29udHJvbHMuaGVpZ2h0LCBcInB4XCIpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZVNjYWxlOiBmdW5jdGlvbiBoYW5kbGVTY2FsZShzY2FsZVR5cGUsIGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZHJhZyA9IE9iamVjdChsaWJbXCJzY2FsZVwiXSkoc2NhbGVUeXBlLCB7XG4gICAgICAgIHN0YXJ0WDogZXZlbnQucGFnZVgsXG4gICAgICAgIHN0YXJ0WTogZXZlbnQucGFnZVksXG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55LFxuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgIHNjYWxlTGltaXQ6IHRoaXMuc2NhbGVMaW1pdCxcbiAgICAgICAgc2NhbGVGcm9tQ2VudGVyOiB0aGlzLnNjYWxlRnJvbUNlbnRlciAmJiBldmVudC5hbHRLZXksXG4gICAgICAgIGVuYWJsZVNjYWxlRnJvbUNlbnRlcjogdGhpcy5zY2FsZUZyb21DZW50ZXIsXG4gICAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmFzcGVjdFJhdGlvICYmIGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICBlbmFibGVBc3BlY3RSYXRpbzogdGhpcy5hc3BlY3RSYXRpb1xuICAgICAgfSwgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgX3RoaXMuJGVtaXQoXCJ1cGRhdGVcIiwgcGF5bG9hZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub25EcmFnKGRyYWcpO1xuICAgIH0sXG4gICAgaGFuZGxlVHJhbnNsYXRpb246IGZ1bmN0aW9uIGhhbmRsZVRyYW5zbGF0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgZHJhZyA9IE9iamVjdChsaWJbXCJ0cmFuc2xhdGVcIl0pKHtcbiAgICAgICAgeDogdGhpcy54LFxuICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgIHN0YXJ0WDogZXZlbnQucGFnZVgsXG4gICAgICAgIHN0YXJ0WTogZXZlbnQucGFnZVlcbiAgICAgIH0sIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIF90aGlzMi4kZW1pdChcInVwZGF0ZVwiLCBwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkRyYWcoZHJhZyk7XG4gICAgfSxcbiAgICBoYW5kbGVSb3RhdGlvbjogZnVuY3Rpb24gaGFuZGxlUm90YXRpb24oZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHZhciBkcmFnID0gT2JqZWN0KGxpYltcInJvdGF0ZVwiXSkoe1xuICAgICAgICBzdGFydFg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICBzdGFydFk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICB4OiB0aGlzLngsXG4gICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WVxuICAgICAgfSwgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgX3RoaXMzLiRlbWl0KFwidXBkYXRlXCIsIHBheWxvYWQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uRHJhZyhkcmFnKTtcbiAgICB9LFxuICAgIG9uRHJhZzogZnVuY3Rpb24gb25EcmFnKGRyYWcpIHtcbiAgICAgIHZhciB1cCA9IGZ1bmN0aW9uIHVwKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwKTtcbiAgICAgIH07XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwKTtcbiAgICB9LFxuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KFwibW91c2Vkb3duXCIsIGV2ZW50KTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0T24gPT09ICdtb3VzZWRvd24nIHx8IHRoaXMuc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnb25TZWxlY3QnKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2xhdGlvbihldmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsaWNrJywgZXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RPbiA9PT0gJ2NsaWNrJykge1xuICAgICAgICB0aGlzLiRlbWl0KCdvblNlbGVjdCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGJsQ2xpY2s6IGZ1bmN0aW9uIGRibENsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdkYmxjbGljaycsIGV2ZW50KTtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0T24gPT09ICdkYmxjbGljaycpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnb25TZWxlY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9GcmVlVHJhbnNmb3JtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX0ZyZWVUcmFuc2Zvcm12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoRnJlZVRyYW5zZm9ybXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL0ZyZWVUcmFuc2Zvcm0udnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX0ZyZWVUcmFuc2Zvcm12dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJGcmVlVHJhbnNmb3JtLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBGcmVlVHJhbnNmb3JtID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B2dWUvY2xpLXNlcnZpY2UvbGliL2NvbW1hbmRzL2J1aWxkL2VudHJ5LWxpYi5qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVudHJ5X2xpYiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEZyZWVUcmFuc2Zvcm0pO1xuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmRlZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJlZVRyYW5zZm9ybS5jb21tb24uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-free-transform/dist/FreeTransform.common.js\n");

/***/ })

}]);